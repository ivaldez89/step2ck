"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/flashcards/page",{

/***/ "(app-pages-browser)/./src/hooks/useFlashcards.ts":
/*!************************************!*\
  !*** ./src/hooks/useFlashcards.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFlashcards: function() { return /* binding */ useFlashcards; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_storage_localStorage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/storage/localStorage */ \"(app-pages-browser)/./src/lib/storage/localStorage.ts\");\n/* harmony import */ var _lib_spaced_repetition_fsrs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/spaced-repetition/fsrs */ \"(app-pages-browser)/./src/lib/spaced-repetition/fsrs.ts\");\n/* __next_internal_client_entry_do_not_use__ useFlashcards auto */ \n\n\nfunction useFlashcards() {\n    const [cards, setCards] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [dueCards, setDueCards] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [currentIndex, setCurrentIndex] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [isRevealed, setIsRevealed] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [session, setSession] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [reviewStartTime, setReviewStartTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [intervalPreview, setIntervalPreview] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Load cards on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        setIsLoading(true);\n        // Seed sample cards if none exist\n        (0,_lib_storage_localStorage__WEBPACK_IMPORTED_MODULE_1__.seedFlashcards)();\n        // Load cards\n        const loadedCards = (0,_lib_storage_localStorage__WEBPACK_IMPORTED_MODULE_1__.getFlashcards)();\n        setCards(loadedCards);\n        // Get due cards\n        const due = (0,_lib_spaced_repetition_fsrs__WEBPACK_IMPORTED_MODULE_2__.getDueCards)(loadedCards);\n        setDueCards(due);\n        setIsLoading(false);\n    }, []);\n    // Current card\n    const currentCard = dueCards[currentIndex] || null;\n    // Calculate interval preview when card changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (currentCard && isRevealed) {\n            setIntervalPreview((0,_lib_spaced_repetition_fsrs__WEBPACK_IMPORTED_MODULE_2__.previewSchedule)(currentCard));\n        } else {\n            setIntervalPreview(null);\n        }\n    }, [\n        currentCard,\n        isRevealed\n    ]);\n    // Calculate stats\n    const stats = (0,_lib_spaced_repetition_fsrs__WEBPACK_IMPORTED_MODULE_2__.calculateStats)(cards);\n    // Refresh cards from storage\n    const refreshCards = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const loadedCards = (0,_lib_storage_localStorage__WEBPACK_IMPORTED_MODULE_1__.getFlashcards)();\n        setCards(loadedCards);\n        setDueCards((0,_lib_spaced_repetition_fsrs__WEBPACK_IMPORTED_MODULE_2__.getDueCards)(loadedCards));\n    }, []);\n    // Reveal answer\n    const revealAnswer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setIsRevealed(true);\n        setReviewStartTime(Date.now());\n    }, []);\n    // Rate card and schedule next review\n    const rateCard = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((rating)=>{\n        if (!currentCard) return;\n        // Calculate new scheduling\n        const result = (0,_lib_spaced_repetition_fsrs__WEBPACK_IMPORTED_MODULE_2__.scheduleCard)(currentCard, rating);\n        // Update the card\n        const updatedCard = {\n            ...currentCard,\n            updatedAt: new Date().toISOString(),\n            spacedRepetition: {\n                state: result.state,\n                interval: result.interval,\n                ease: result.ease,\n                reps: currentCard.spacedRepetition.reps + (rating !== \"again\" ? 1 : 0),\n                lapses: currentCard.spacedRepetition.lapses + (rating === \"again\" ? 1 : 0),\n                nextReview: result.nextReview.toISOString(),\n                lastReview: new Date().toISOString(),\n                stability: result.stability,\n                difficulty: result.difficulty\n            }\n        };\n        // Save to storage\n        (0,_lib_storage_localStorage__WEBPACK_IMPORTED_MODULE_1__.saveFlashcard)(updatedCard);\n        // Update session if active\n        if (session && reviewStartTime) {\n            const reviewRecord = {\n                cardId: currentCard.id,\n                rating,\n                reviewedAt: new Date().toISOString(),\n                timeSpent: Date.now() - reviewStartTime,\n                previousState: currentCard.spacedRepetition.state,\n                newState: result.state\n            };\n            const updatedSession = {\n                ...session,\n                cardsReviewed: session.cardsReviewed + 1,\n                cardsCorrect: session.cardsCorrect + (rating !== \"again\" ? 1 : 0),\n                cardsFailed: session.cardsFailed + (rating === \"again\" ? 1 : 0),\n                reviews: [\n                    ...session.reviews,\n                    reviewRecord\n                ]\n            };\n            setSession(updatedSession);\n            (0,_lib_storage_localStorage__WEBPACK_IMPORTED_MODULE_1__.saveSession)(updatedSession);\n        }\n        // Update local state\n        const updatedCards = cards.map((c)=>c.id === updatedCard.id ? updatedCard : c);\n        setCards(updatedCards);\n        // Remove from due cards if no longer due (or move to end if still learning)\n        if (result.state === \"learning\" || result.state === \"relearning\") {\n            // Keep in queue but move to end\n            const newDue = [\n                ...dueCards\n            ];\n            newDue.splice(currentIndex, 1);\n            newDue.push(updatedCard);\n            setDueCards(newDue);\n        } else {\n            // Remove from due cards\n            const newDue = dueCards.filter((c)=>c.id !== currentCard.id);\n            setDueCards(newDue);\n            // Adjust index if needed\n            if (currentIndex >= newDue.length && newDue.length > 0) {\n                setCurrentIndex(newDue.length - 1);\n            }\n        }\n        // Reset for next card\n        setIsRevealed(false);\n        setReviewStartTime(null);\n    }, [\n        currentCard,\n        cards,\n        dueCards,\n        currentIndex,\n        session,\n        reviewStartTime\n    ]);\n    // Navigation\n    const nextCard = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (currentIndex < dueCards.length - 1) {\n            setCurrentIndex(currentIndex + 1);\n            setIsRevealed(false);\n        }\n    }, [\n        currentIndex,\n        dueCards.length\n    ]);\n    const previousCard = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (currentIndex > 0) {\n            setCurrentIndex(currentIndex - 1);\n            setIsRevealed(false);\n        }\n    }, [\n        currentIndex\n    ]);\n    const goToCard = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((index)=>{\n        if (index >= 0 && index < dueCards.length) {\n            setCurrentIndex(index);\n            setIsRevealed(false);\n        }\n    }, [\n        dueCards.length\n    ]);\n    // Session management\n    const startSession = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const newSession = {\n            id: crypto.randomUUID(),\n            startedAt: new Date().toISOString(),\n            cardsReviewed: 0,\n            cardsCorrect: 0,\n            cardsFailed: 0,\n            reviews: []\n        };\n        setSession(newSession);\n        setCurrentIndex(0);\n        setIsRevealed(false);\n    }, []);\n    const endSession = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (session) {\n            const endedSession = {\n                ...session,\n                endedAt: new Date().toISOString()\n            };\n            (0,_lib_storage_localStorage__WEBPACK_IMPORTED_MODULE_1__.saveSession)(endedSession);\n        }\n        setSession(null);\n    }, [\n        session\n    ]);\n    // Add new card\n    const addCard = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((cardData)=>{\n        const now = new Date().toISOString();\n        const newCard = {\n            ...cardData,\n            id: crypto.randomUUID(),\n            schemaVersion: \"1.0\",\n            createdAt: now,\n            updatedAt: now\n        };\n        (0,_lib_storage_localStorage__WEBPACK_IMPORTED_MODULE_1__.saveFlashcard)(newCard);\n        const updatedCards = [\n            ...cards,\n            newCard\n        ];\n        setCards(updatedCards);\n        // Add to due cards if it's due\n        const due = (0,_lib_spaced_repetition_fsrs__WEBPACK_IMPORTED_MODULE_2__.getDueCards)(updatedCards);\n        setDueCards(due);\n    }, [\n        cards\n    ]);\n    // Add multiple cards (merge without duplicates)\n    const addCards = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((newCards)=>{\n        const existingIds = new Set(cards.map((c)=>c.id));\n        // Filter out cards that already exist (by ID)\n        // Also check for duplicate content\n        const existingContent = new Set(cards.map((c)=>c.content.front.toLowerCase().trim()));\n        const uniqueNewCards = newCards.filter((newCard)=>{\n            const isDuplicateId = existingIds.has(newCard.id);\n            const isDuplicateContent = existingContent.has(newCard.content.front.toLowerCase().trim());\n            return !isDuplicateId && !isDuplicateContent;\n        });\n        if (uniqueNewCards.length === 0) {\n            console.log(\"No new unique cards to add\");\n            return;\n        }\n        // Merge with existing cards\n        const mergedCards = [\n            ...cards,\n            ...uniqueNewCards\n        ];\n        // Save to storage\n        (0,_lib_storage_localStorage__WEBPACK_IMPORTED_MODULE_1__.saveFlashcards)(mergedCards);\n        // Update state\n        setCards(mergedCards);\n        setDueCards((0,_lib_spaced_repetition_fsrs__WEBPACK_IMPORTED_MODULE_2__.getDueCards)(mergedCards));\n        console.log(\"Added \".concat(uniqueNewCards.length, \" new cards\"));\n    }, [\n        cards\n    ]);\n    return {\n        cards,\n        dueCards,\n        currentCard,\n        currentIndex,\n        isRevealed,\n        isLoading,\n        stats,\n        session,\n        intervalPreview,\n        revealAnswer,\n        rateCard,\n        nextCard,\n        previousCard,\n        goToCard,\n        startSession,\n        endSession,\n        addCard,\n        addCards,\n        refreshCards\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VGbGFzaGNhcmRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O21FQUV5RDtBQVFyQjtBQU1FO0FBMkIvQixTQUFTWTtJQUNkLE1BQU0sQ0FBQ0MsT0FBT0MsU0FBUyxHQUFHZCwrQ0FBUUEsQ0FBYyxFQUFFO0lBQ2xELE1BQU0sQ0FBQ2UsVUFBVUMsWUFBWSxHQUFHaEIsK0NBQVFBLENBQWMsRUFBRTtJQUN4RCxNQUFNLENBQUNpQixjQUFjQyxnQkFBZ0IsR0FBR2xCLCtDQUFRQSxDQUFDO0lBQ2pELE1BQU0sQ0FBQ21CLFlBQVlDLGNBQWMsR0FBR3BCLCtDQUFRQSxDQUFDO0lBQzdDLE1BQU0sQ0FBQ3FCLFdBQVdDLGFBQWEsR0FBR3RCLCtDQUFRQSxDQUFDO0lBQzNDLE1BQU0sQ0FBQ3VCLFNBQVNDLFdBQVcsR0FBR3hCLCtDQUFRQSxDQUF1QjtJQUM3RCxNQUFNLENBQUN5QixpQkFBaUJDLG1CQUFtQixHQUFHMUIsK0NBQVFBLENBQWdCO0lBQ3RFLE1BQU0sQ0FBQzJCLGlCQUFpQkMsbUJBQW1CLEdBQUc1QiwrQ0FBUUEsQ0FBZ0M7SUFFdEYsc0JBQXNCO0lBQ3RCQyxnREFBU0EsQ0FBQztRQUNScUIsYUFBYTtRQUViLGtDQUFrQztRQUNsQ2hCLHlFQUFjQTtRQUVkLGFBQWE7UUFDYixNQUFNdUIsY0FBYzFCLHdFQUFhQTtRQUNqQ1csU0FBU2U7UUFFVCxnQkFBZ0I7UUFDaEIsTUFBTUMsTUFBTXJCLHdFQUFXQSxDQUFDb0I7UUFDeEJiLFlBQVljO1FBRVpSLGFBQWE7SUFDZixHQUFHLEVBQUU7SUFFTCxlQUFlO0lBQ2YsTUFBTVMsY0FBY2hCLFFBQVEsQ0FBQ0UsYUFBYSxJQUFJO0lBRTlDLCtDQUErQztJQUMvQ2hCLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSThCLGVBQWVaLFlBQVk7WUFDN0JTLG1CQUFtQmpCLDRFQUFlQSxDQUFDb0I7UUFDckMsT0FBTztZQUNMSCxtQkFBbUI7UUFDckI7SUFDRixHQUFHO1FBQUNHO1FBQWFaO0tBQVc7SUFFNUIsa0JBQWtCO0lBQ2xCLE1BQU1hLFFBQVF0QiwyRUFBY0EsQ0FBQ0c7SUFFN0IsNkJBQTZCO0lBQzdCLE1BQU1vQixlQUFlL0Isa0RBQVdBLENBQUM7UUFDL0IsTUFBTTJCLGNBQWMxQix3RUFBYUE7UUFDakNXLFNBQVNlO1FBQ1RiLFlBQVlQLHdFQUFXQSxDQUFDb0I7SUFDMUIsR0FBRyxFQUFFO0lBRUwsZ0JBQWdCO0lBQ2hCLE1BQU1LLGVBQWVoQyxrREFBV0EsQ0FBQztRQUMvQmtCLGNBQWM7UUFDZE0sbUJBQW1CUyxLQUFLQyxHQUFHO0lBQzdCLEdBQUcsRUFBRTtJQUVMLHFDQUFxQztJQUNyQyxNQUFNQyxXQUFXbkMsa0RBQVdBLENBQUMsQ0FBQ29DO1FBQzVCLElBQUksQ0FBQ1AsYUFBYTtRQUVsQiwyQkFBMkI7UUFDM0IsTUFBTVEsU0FBUy9CLHlFQUFZQSxDQUFDdUIsYUFBYU87UUFFekMsa0JBQWtCO1FBQ2xCLE1BQU1FLGNBQXlCO1lBQzdCLEdBQUdULFdBQVc7WUFDZFUsV0FBVyxJQUFJTixPQUFPTyxXQUFXO1lBQ2pDQyxrQkFBa0I7Z0JBQ2hCQyxPQUFPTCxPQUFPSyxLQUFLO2dCQUNuQkMsVUFBVU4sT0FBT00sUUFBUTtnQkFDekJDLE1BQU1QLE9BQU9PLElBQUk7Z0JBQ2pCQyxNQUFNaEIsWUFBWVksZ0JBQWdCLENBQUNJLElBQUksR0FBSVQsQ0FBQUEsV0FBVyxVQUFVLElBQUk7Z0JBQ3BFVSxRQUFRakIsWUFBWVksZ0JBQWdCLENBQUNLLE1BQU0sR0FBSVYsQ0FBQUEsV0FBVyxVQUFVLElBQUk7Z0JBQ3hFVyxZQUFZVixPQUFPVSxVQUFVLENBQUNQLFdBQVc7Z0JBQ3pDUSxZQUFZLElBQUlmLE9BQU9PLFdBQVc7Z0JBQ2xDUyxXQUFXWixPQUFPWSxTQUFTO2dCQUMzQkMsWUFBWWIsT0FBT2EsVUFBVTtZQUMvQjtRQUNGO1FBRUEsa0JBQWtCO1FBQ2xCaEQsd0VBQWFBLENBQUNvQztRQUVkLDJCQUEyQjtRQUMzQixJQUFJakIsV0FBV0UsaUJBQWlCO1lBQzlCLE1BQU00QixlQUE2QjtnQkFDakNDLFFBQVF2QixZQUFZd0IsRUFBRTtnQkFDdEJqQjtnQkFDQWtCLFlBQVksSUFBSXJCLE9BQU9PLFdBQVc7Z0JBQ2xDZSxXQUFXdEIsS0FBS0MsR0FBRyxLQUFLWDtnQkFDeEJpQyxlQUFlM0IsWUFBWVksZ0JBQWdCLENBQUNDLEtBQUs7Z0JBQ2pEZSxVQUFVcEIsT0FBT0ssS0FBSztZQUN4QjtZQUVBLE1BQU1nQixpQkFBZ0M7Z0JBQ3BDLEdBQUdyQyxPQUFPO2dCQUNWc0MsZUFBZXRDLFFBQVFzQyxhQUFhLEdBQUc7Z0JBQ3ZDQyxjQUFjdkMsUUFBUXVDLFlBQVksR0FBSXhCLENBQUFBLFdBQVcsVUFBVSxJQUFJO2dCQUMvRHlCLGFBQWF4QyxRQUFRd0MsV0FBVyxHQUFJekIsQ0FBQUEsV0FBVyxVQUFVLElBQUk7Z0JBQzdEMEIsU0FBUzt1QkFBSXpDLFFBQVF5QyxPQUFPO29CQUFFWDtpQkFBYTtZQUM3QztZQUVBN0IsV0FBV29DO1lBQ1hyRCxzRUFBV0EsQ0FBQ3FEO1FBQ2Q7UUFFQSxxQkFBcUI7UUFDckIsTUFBTUssZUFBZXBELE1BQU1xRCxHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVaLEVBQUUsS0FBS2YsWUFBWWUsRUFBRSxHQUFHZixjQUFjMkI7UUFDNUVyRCxTQUFTbUQ7UUFFVCw0RUFBNEU7UUFDNUUsSUFBSTFCLE9BQU9LLEtBQUssS0FBSyxjQUFjTCxPQUFPSyxLQUFLLEtBQUssY0FBYztZQUNoRSxnQ0FBZ0M7WUFDaEMsTUFBTXdCLFNBQVM7bUJBQUlyRDthQUFTO1lBQzVCcUQsT0FBT0MsTUFBTSxDQUFDcEQsY0FBYztZQUM1Qm1ELE9BQU9FLElBQUksQ0FBQzlCO1lBQ1p4QixZQUFZb0Q7UUFDZCxPQUFPO1lBQ0wsd0JBQXdCO1lBQ3hCLE1BQU1BLFNBQVNyRCxTQUFTd0QsTUFBTSxDQUFDSixDQUFBQSxJQUFLQSxFQUFFWixFQUFFLEtBQUt4QixZQUFZd0IsRUFBRTtZQUMzRHZDLFlBQVlvRDtZQUVaLHlCQUF5QjtZQUN6QixJQUFJbkQsZ0JBQWdCbUQsT0FBT0ksTUFBTSxJQUFJSixPQUFPSSxNQUFNLEdBQUcsR0FBRztnQkFDdER0RCxnQkFBZ0JrRCxPQUFPSSxNQUFNLEdBQUc7WUFDbEM7UUFDRjtRQUVBLHNCQUFzQjtRQUN0QnBELGNBQWM7UUFDZE0sbUJBQW1CO0lBQ3JCLEdBQUc7UUFBQ0s7UUFBYWxCO1FBQU9FO1FBQVVFO1FBQWNNO1FBQVNFO0tBQWdCO0lBRXpFLGFBQWE7SUFDYixNQUFNZ0QsV0FBV3ZFLGtEQUFXQSxDQUFDO1FBQzNCLElBQUllLGVBQWVGLFNBQVN5RCxNQUFNLEdBQUcsR0FBRztZQUN0Q3RELGdCQUFnQkQsZUFBZTtZQUMvQkcsY0FBYztRQUNoQjtJQUNGLEdBQUc7UUFBQ0g7UUFBY0YsU0FBU3lELE1BQU07S0FBQztJQUVsQyxNQUFNRSxlQUFleEUsa0RBQVdBLENBQUM7UUFDL0IsSUFBSWUsZUFBZSxHQUFHO1lBQ3BCQyxnQkFBZ0JELGVBQWU7WUFDL0JHLGNBQWM7UUFDaEI7SUFDRixHQUFHO1FBQUNIO0tBQWE7SUFFakIsTUFBTTBELFdBQVd6RSxrREFBV0EsQ0FBQyxDQUFDMEU7UUFDNUIsSUFBSUEsU0FBUyxLQUFLQSxRQUFRN0QsU0FBU3lELE1BQU0sRUFBRTtZQUN6Q3RELGdCQUFnQjBEO1lBQ2hCeEQsY0FBYztRQUNoQjtJQUNGLEdBQUc7UUFBQ0wsU0FBU3lELE1BQU07S0FBQztJQUVwQixxQkFBcUI7SUFDckIsTUFBTUssZUFBZTNFLGtEQUFXQSxDQUFDO1FBQy9CLE1BQU00RSxhQUE0QjtZQUNoQ3ZCLElBQUl3QixPQUFPQyxVQUFVO1lBQ3JCQyxXQUFXLElBQUk5QyxPQUFPTyxXQUFXO1lBQ2pDbUIsZUFBZTtZQUNmQyxjQUFjO1lBQ2RDLGFBQWE7WUFDYkMsU0FBUyxFQUFFO1FBQ2I7UUFDQXhDLFdBQVdzRDtRQUNYNUQsZ0JBQWdCO1FBQ2hCRSxjQUFjO0lBQ2hCLEdBQUcsRUFBRTtJQUVMLE1BQU04RCxhQUFhaEYsa0RBQVdBLENBQUM7UUFDN0IsSUFBSXFCLFNBQVM7WUFDWCxNQUFNNEQsZUFBOEI7Z0JBQ2xDLEdBQUc1RCxPQUFPO2dCQUNWNkQsU0FBUyxJQUFJakQsT0FBT08sV0FBVztZQUNqQztZQUNBbkMsc0VBQVdBLENBQUM0RTtRQUNkO1FBQ0EzRCxXQUFXO0lBQ2IsR0FBRztRQUFDRDtLQUFRO0lBRVosZUFBZTtJQUNmLE1BQU04RCxVQUFVbkYsa0RBQVdBLENBQUMsQ0FDMUJvRjtRQUVBLE1BQU1sRCxNQUFNLElBQUlELE9BQU9PLFdBQVc7UUFDbEMsTUFBTTZDLFVBQXFCO1lBQ3pCLEdBQUdELFFBQVE7WUFDWC9CLElBQUl3QixPQUFPQyxVQUFVO1lBQ3JCUSxlQUFlO1lBQ2ZDLFdBQVdyRDtZQUNYSyxXQUFXTDtRQUNiO1FBRUFoQyx3RUFBYUEsQ0FBQ21GO1FBRWQsTUFBTXRCLGVBQWU7ZUFBSXBEO1lBQU8wRTtTQUFRO1FBQ3hDekUsU0FBU21EO1FBRVQsK0JBQStCO1FBQy9CLE1BQU1uQyxNQUFNckIsd0VBQVdBLENBQUN3RDtRQUN4QmpELFlBQVljO0lBQ2QsR0FBRztRQUFDakI7S0FBTTtJQUVWLGdEQUFnRDtJQUNoRCxNQUFNNkUsV0FBV3hGLGtEQUFXQSxDQUFDLENBQUN5RjtRQUM1QixNQUFNQyxjQUFjLElBQUlDLElBQUloRixNQUFNcUQsR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFWixFQUFFO1FBRS9DLDhDQUE4QztRQUM5QyxtQ0FBbUM7UUFDbkMsTUFBTXVDLGtCQUFrQixJQUFJRCxJQUFJaEYsTUFBTXFELEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRTRCLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDQyxXQUFXLEdBQUdDLElBQUk7UUFFakYsTUFBTUMsaUJBQWlCUixTQUFTcEIsTUFBTSxDQUFDZ0IsQ0FBQUE7WUFDckMsTUFBTWEsZ0JBQWdCUixZQUFZUyxHQUFHLENBQUNkLFFBQVFoQyxFQUFFO1lBQ2hELE1BQU0rQyxxQkFBcUJSLGdCQUFnQk8sR0FBRyxDQUFDZCxRQUFRUSxPQUFPLENBQUNDLEtBQUssQ0FBQ0MsV0FBVyxHQUFHQyxJQUFJO1lBQ3ZGLE9BQU8sQ0FBQ0UsaUJBQWlCLENBQUNFO1FBQzVCO1FBRUEsSUFBSUgsZUFBZTNCLE1BQU0sS0FBSyxHQUFHO1lBQy9CK0IsUUFBUUMsR0FBRyxDQUFDO1lBQ1o7UUFDRjtRQUVBLDRCQUE0QjtRQUM1QixNQUFNQyxjQUFjO2VBQUk1RjtlQUFVc0Y7U0FBZTtRQUVqRCxrQkFBa0I7UUFDbEI5Rix5RUFBY0EsQ0FBQ29HO1FBRWYsZUFBZTtRQUNmM0YsU0FBUzJGO1FBQ1R6RixZQUFZUCx3RUFBV0EsQ0FBQ2dHO1FBRXhCRixRQUFRQyxHQUFHLENBQUMsU0FBK0IsT0FBdEJMLGVBQWUzQixNQUFNLEVBQUM7SUFDN0MsR0FBRztRQUFDM0Q7S0FBTTtJQUVWLE9BQU87UUFDTEE7UUFDQUU7UUFDQWdCO1FBQ0FkO1FBQ0FFO1FBQ0FFO1FBQ0FXO1FBQ0FUO1FBQ0FJO1FBQ0FPO1FBQ0FHO1FBQ0FvQztRQUNBQztRQUNBQztRQUNBRTtRQUNBSztRQUNBRztRQUNBSztRQUNBekQ7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9ob29rcy91c2VGbGFzaGNhcmRzLnRzPzk0ZGEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB0eXBlIHsgRmxhc2hjYXJkLCBSYXRpbmcsIFJldmlld1Nlc3Npb24sIFJldmlld1JlY29yZCB9IGZyb20gJ0AvdHlwZXMnO1xuaW1wb3J0IHsgXG4gIGdldEZsYXNoY2FyZHMsIFxuICBzYXZlRmxhc2hjYXJkLCBcbiAgc2F2ZUZsYXNoY2FyZHMsXG4gIHNlZWRGbGFzaGNhcmRzLFxuICBzYXZlU2Vzc2lvbiBcbn0gZnJvbSAnQC9saWIvc3RvcmFnZS9sb2NhbFN0b3JhZ2UnO1xuaW1wb3J0IHsgXG4gIHNjaGVkdWxlQ2FyZCwgXG4gIGdldER1ZUNhcmRzLCBcbiAgY2FsY3VsYXRlU3RhdHMsXG4gIHByZXZpZXdTY2hlZHVsZSBcbn0gZnJvbSAnQC9saWIvc3BhY2VkLXJlcGV0aXRpb24vZnNycyc7XG5cbmludGVyZmFjZSBVc2VGbGFzaGNhcmRzUmV0dXJuIHtcbiAgLy8gU3RhdGVcbiAgY2FyZHM6IEZsYXNoY2FyZFtdO1xuICBkdWVDYXJkczogRmxhc2hjYXJkW107XG4gIGN1cnJlbnRDYXJkOiBGbGFzaGNhcmQgfCBudWxsO1xuICBjdXJyZW50SW5kZXg6IG51bWJlcjtcbiAgaXNSZXZlYWxlZDogYm9vbGVhbjtcbiAgaXNMb2FkaW5nOiBib29sZWFuO1xuICBzdGF0czogUmV0dXJuVHlwZTx0eXBlb2YgY2FsY3VsYXRlU3RhdHM+O1xuICBzZXNzaW9uOiBSZXZpZXdTZXNzaW9uIHwgbnVsbDtcbiAgaW50ZXJ2YWxQcmV2aWV3OiBSZWNvcmQ8UmF0aW5nLCBudW1iZXI+IHwgbnVsbDtcbiAgXG4gIC8vIEFjdGlvbnNcbiAgcmV2ZWFsQW5zd2VyOiAoKSA9PiB2b2lkO1xuICByYXRlQ2FyZDogKHJhdGluZzogUmF0aW5nKSA9PiB2b2lkO1xuICBuZXh0Q2FyZDogKCkgPT4gdm9pZDtcbiAgcHJldmlvdXNDYXJkOiAoKSA9PiB2b2lkO1xuICBnb1RvQ2FyZDogKGluZGV4OiBudW1iZXIpID0+IHZvaWQ7XG4gIHN0YXJ0U2Vzc2lvbjogKCkgPT4gdm9pZDtcbiAgZW5kU2Vzc2lvbjogKCkgPT4gdm9pZDtcbiAgYWRkQ2FyZDogKGNhcmQ6IE9taXQ8Rmxhc2hjYXJkLCAnaWQnIHwgJ3NjaGVtYVZlcnNpb24nIHwgJ2NyZWF0ZWRBdCcgfCAndXBkYXRlZEF0Jz4pID0+IHZvaWQ7XG4gIGFkZENhcmRzOiAoY2FyZHM6IEZsYXNoY2FyZFtdKSA9PiB2b2lkO1xuICByZWZyZXNoQ2FyZHM6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VGbGFzaGNhcmRzKCk6IFVzZUZsYXNoY2FyZHNSZXR1cm4ge1xuICBjb25zdCBbY2FyZHMsIHNldENhcmRzXSA9IHVzZVN0YXRlPEZsYXNoY2FyZFtdPihbXSk7XG4gIGNvbnN0IFtkdWVDYXJkcywgc2V0RHVlQ2FyZHNdID0gdXNlU3RhdGU8Rmxhc2hjYXJkW10+KFtdKTtcbiAgY29uc3QgW2N1cnJlbnRJbmRleCwgc2V0Q3VycmVudEluZGV4XSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbaXNSZXZlYWxlZCwgc2V0SXNSZXZlYWxlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW3Nlc3Npb24sIHNldFNlc3Npb25dID0gdXNlU3RhdGU8UmV2aWV3U2Vzc2lvbiB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbcmV2aWV3U3RhcnRUaW1lLCBzZXRSZXZpZXdTdGFydFRpbWVdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtpbnRlcnZhbFByZXZpZXcsIHNldEludGVydmFsUHJldmlld10gPSB1c2VTdGF0ZTxSZWNvcmQ8UmF0aW5nLCBudW1iZXI+IHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gTG9hZCBjYXJkcyBvbiBtb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICBcbiAgICAvLyBTZWVkIHNhbXBsZSBjYXJkcyBpZiBub25lIGV4aXN0XG4gICAgc2VlZEZsYXNoY2FyZHMoKTtcbiAgICBcbiAgICAvLyBMb2FkIGNhcmRzXG4gICAgY29uc3QgbG9hZGVkQ2FyZHMgPSBnZXRGbGFzaGNhcmRzKCk7XG4gICAgc2V0Q2FyZHMobG9hZGVkQ2FyZHMpO1xuICAgIFxuICAgIC8vIEdldCBkdWUgY2FyZHNcbiAgICBjb25zdCBkdWUgPSBnZXREdWVDYXJkcyhsb2FkZWRDYXJkcyk7XG4gICAgc2V0RHVlQ2FyZHMoZHVlKTtcbiAgICBcbiAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICB9LCBbXSk7XG5cbiAgLy8gQ3VycmVudCBjYXJkXG4gIGNvbnN0IGN1cnJlbnRDYXJkID0gZHVlQ2FyZHNbY3VycmVudEluZGV4XSB8fCBudWxsO1xuXG4gIC8vIENhbGN1bGF0ZSBpbnRlcnZhbCBwcmV2aWV3IHdoZW4gY2FyZCBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRDYXJkICYmIGlzUmV2ZWFsZWQpIHtcbiAgICAgIHNldEludGVydmFsUHJldmlldyhwcmV2aWV3U2NoZWR1bGUoY3VycmVudENhcmQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0SW50ZXJ2YWxQcmV2aWV3KG51bGwpO1xuICAgIH1cbiAgfSwgW2N1cnJlbnRDYXJkLCBpc1JldmVhbGVkXSk7XG5cbiAgLy8gQ2FsY3VsYXRlIHN0YXRzXG4gIGNvbnN0IHN0YXRzID0gY2FsY3VsYXRlU3RhdHMoY2FyZHMpO1xuXG4gIC8vIFJlZnJlc2ggY2FyZHMgZnJvbSBzdG9yYWdlXG4gIGNvbnN0IHJlZnJlc2hDYXJkcyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBsb2FkZWRDYXJkcyA9IGdldEZsYXNoY2FyZHMoKTtcbiAgICBzZXRDYXJkcyhsb2FkZWRDYXJkcyk7XG4gICAgc2V0RHVlQ2FyZHMoZ2V0RHVlQ2FyZHMobG9hZGVkQ2FyZHMpKTtcbiAgfSwgW10pO1xuXG4gIC8vIFJldmVhbCBhbnN3ZXJcbiAgY29uc3QgcmV2ZWFsQW5zd2VyID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldElzUmV2ZWFsZWQodHJ1ZSk7XG4gICAgc2V0UmV2aWV3U3RhcnRUaW1lKERhdGUubm93KCkpO1xuICB9LCBbXSk7XG5cbiAgLy8gUmF0ZSBjYXJkIGFuZCBzY2hlZHVsZSBuZXh0IHJldmlld1xuICBjb25zdCByYXRlQ2FyZCA9IHVzZUNhbGxiYWNrKChyYXRpbmc6IFJhdGluZykgPT4ge1xuICAgIGlmICghY3VycmVudENhcmQpIHJldHVybjtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgbmV3IHNjaGVkdWxpbmdcbiAgICBjb25zdCByZXN1bHQgPSBzY2hlZHVsZUNhcmQoY3VycmVudENhcmQsIHJhdGluZyk7XG4gICAgXG4gICAgLy8gVXBkYXRlIHRoZSBjYXJkXG4gICAgY29uc3QgdXBkYXRlZENhcmQ6IEZsYXNoY2FyZCA9IHtcbiAgICAgIC4uLmN1cnJlbnRDYXJkLFxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBzcGFjZWRSZXBldGl0aW9uOiB7XG4gICAgICAgIHN0YXRlOiByZXN1bHQuc3RhdGUsXG4gICAgICAgIGludGVydmFsOiByZXN1bHQuaW50ZXJ2YWwsXG4gICAgICAgIGVhc2U6IHJlc3VsdC5lYXNlLFxuICAgICAgICByZXBzOiBjdXJyZW50Q2FyZC5zcGFjZWRSZXBldGl0aW9uLnJlcHMgKyAocmF0aW5nICE9PSAnYWdhaW4nID8gMSA6IDApLFxuICAgICAgICBsYXBzZXM6IGN1cnJlbnRDYXJkLnNwYWNlZFJlcGV0aXRpb24ubGFwc2VzICsgKHJhdGluZyA9PT0gJ2FnYWluJyA/IDEgOiAwKSxcbiAgICAgICAgbmV4dFJldmlldzogcmVzdWx0Lm5leHRSZXZpZXcudG9JU09TdHJpbmcoKSxcbiAgICAgICAgbGFzdFJldmlldzogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBzdGFiaWxpdHk6IHJlc3VsdC5zdGFiaWxpdHksXG4gICAgICAgIGRpZmZpY3VsdHk6IHJlc3VsdC5kaWZmaWN1bHR5XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvLyBTYXZlIHRvIHN0b3JhZ2VcbiAgICBzYXZlRmxhc2hjYXJkKHVwZGF0ZWRDYXJkKTtcbiAgICBcbiAgICAvLyBVcGRhdGUgc2Vzc2lvbiBpZiBhY3RpdmVcbiAgICBpZiAoc2Vzc2lvbiAmJiByZXZpZXdTdGFydFRpbWUpIHtcbiAgICAgIGNvbnN0IHJldmlld1JlY29yZDogUmV2aWV3UmVjb3JkID0ge1xuICAgICAgICBjYXJkSWQ6IGN1cnJlbnRDYXJkLmlkLFxuICAgICAgICByYXRpbmcsXG4gICAgICAgIHJldmlld2VkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdGltZVNwZW50OiBEYXRlLm5vdygpIC0gcmV2aWV3U3RhcnRUaW1lLFxuICAgICAgICBwcmV2aW91c1N0YXRlOiBjdXJyZW50Q2FyZC5zcGFjZWRSZXBldGl0aW9uLnN0YXRlLFxuICAgICAgICBuZXdTdGF0ZTogcmVzdWx0LnN0YXRlXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCB1cGRhdGVkU2Vzc2lvbjogUmV2aWV3U2Vzc2lvbiA9IHtcbiAgICAgICAgLi4uc2Vzc2lvbixcbiAgICAgICAgY2FyZHNSZXZpZXdlZDogc2Vzc2lvbi5jYXJkc1Jldmlld2VkICsgMSxcbiAgICAgICAgY2FyZHNDb3JyZWN0OiBzZXNzaW9uLmNhcmRzQ29ycmVjdCArIChyYXRpbmcgIT09ICdhZ2FpbicgPyAxIDogMCksXG4gICAgICAgIGNhcmRzRmFpbGVkOiBzZXNzaW9uLmNhcmRzRmFpbGVkICsgKHJhdGluZyA9PT0gJ2FnYWluJyA/IDEgOiAwKSxcbiAgICAgICAgcmV2aWV3czogWy4uLnNlc3Npb24ucmV2aWV3cywgcmV2aWV3UmVjb3JkXVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgc2V0U2Vzc2lvbih1cGRhdGVkU2Vzc2lvbik7XG4gICAgICBzYXZlU2Vzc2lvbih1cGRhdGVkU2Vzc2lvbik7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSBsb2NhbCBzdGF0ZVxuICAgIGNvbnN0IHVwZGF0ZWRDYXJkcyA9IGNhcmRzLm1hcChjID0+IGMuaWQgPT09IHVwZGF0ZWRDYXJkLmlkID8gdXBkYXRlZENhcmQgOiBjKTtcbiAgICBzZXRDYXJkcyh1cGRhdGVkQ2FyZHMpO1xuICAgIFxuICAgIC8vIFJlbW92ZSBmcm9tIGR1ZSBjYXJkcyBpZiBubyBsb25nZXIgZHVlIChvciBtb3ZlIHRvIGVuZCBpZiBzdGlsbCBsZWFybmluZylcbiAgICBpZiAocmVzdWx0LnN0YXRlID09PSAnbGVhcm5pbmcnIHx8IHJlc3VsdC5zdGF0ZSA9PT0gJ3JlbGVhcm5pbmcnKSB7XG4gICAgICAvLyBLZWVwIGluIHF1ZXVlIGJ1dCBtb3ZlIHRvIGVuZFxuICAgICAgY29uc3QgbmV3RHVlID0gWy4uLmR1ZUNhcmRzXTtcbiAgICAgIG5ld0R1ZS5zcGxpY2UoY3VycmVudEluZGV4LCAxKTtcbiAgICAgIG5ld0R1ZS5wdXNoKHVwZGF0ZWRDYXJkKTtcbiAgICAgIHNldER1ZUNhcmRzKG5ld0R1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbW92ZSBmcm9tIGR1ZSBjYXJkc1xuICAgICAgY29uc3QgbmV3RHVlID0gZHVlQ2FyZHMuZmlsdGVyKGMgPT4gYy5pZCAhPT0gY3VycmVudENhcmQuaWQpO1xuICAgICAgc2V0RHVlQ2FyZHMobmV3RHVlKTtcbiAgICAgIFxuICAgICAgLy8gQWRqdXN0IGluZGV4IGlmIG5lZWRlZFxuICAgICAgaWYgKGN1cnJlbnRJbmRleCA+PSBuZXdEdWUubGVuZ3RoICYmIG5ld0R1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNldEN1cnJlbnRJbmRleChuZXdEdWUubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFJlc2V0IGZvciBuZXh0IGNhcmRcbiAgICBzZXRJc1JldmVhbGVkKGZhbHNlKTtcbiAgICBzZXRSZXZpZXdTdGFydFRpbWUobnVsbCk7XG4gIH0sIFtjdXJyZW50Q2FyZCwgY2FyZHMsIGR1ZUNhcmRzLCBjdXJyZW50SW5kZXgsIHNlc3Npb24sIHJldmlld1N0YXJ0VGltZV0pO1xuXG4gIC8vIE5hdmlnYXRpb25cbiAgY29uc3QgbmV4dENhcmQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRJbmRleCA8IGR1ZUNhcmRzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHNldEN1cnJlbnRJbmRleChjdXJyZW50SW5kZXggKyAxKTtcbiAgICAgIHNldElzUmV2ZWFsZWQoZmFsc2UpO1xuICAgIH1cbiAgfSwgW2N1cnJlbnRJbmRleCwgZHVlQ2FyZHMubGVuZ3RoXSk7XG5cbiAgY29uc3QgcHJldmlvdXNDYXJkID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChjdXJyZW50SW5kZXggPiAwKSB7XG4gICAgICBzZXRDdXJyZW50SW5kZXgoY3VycmVudEluZGV4IC0gMSk7XG4gICAgICBzZXRJc1JldmVhbGVkKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtjdXJyZW50SW5kZXhdKTtcblxuICBjb25zdCBnb1RvQ2FyZCA9IHVzZUNhbGxiYWNrKChpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBkdWVDYXJkcy5sZW5ndGgpIHtcbiAgICAgIHNldEN1cnJlbnRJbmRleChpbmRleCk7XG4gICAgICBzZXRJc1JldmVhbGVkKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtkdWVDYXJkcy5sZW5ndGhdKTtcblxuICAvLyBTZXNzaW9uIG1hbmFnZW1lbnRcbiAgY29uc3Qgc3RhcnRTZXNzaW9uID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IG5ld1Nlc3Npb246IFJldmlld1Nlc3Npb24gPSB7XG4gICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcbiAgICAgIHN0YXJ0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgY2FyZHNSZXZpZXdlZDogMCxcbiAgICAgIGNhcmRzQ29ycmVjdDogMCxcbiAgICAgIGNhcmRzRmFpbGVkOiAwLFxuICAgICAgcmV2aWV3czogW11cbiAgICB9O1xuICAgIHNldFNlc3Npb24obmV3U2Vzc2lvbik7XG4gICAgc2V0Q3VycmVudEluZGV4KDApO1xuICAgIHNldElzUmV2ZWFsZWQoZmFsc2UpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgZW5kU2Vzc2lvbiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgY29uc3QgZW5kZWRTZXNzaW9uOiBSZXZpZXdTZXNzaW9uID0ge1xuICAgICAgICAuLi5zZXNzaW9uLFxuICAgICAgICBlbmRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH07XG4gICAgICBzYXZlU2Vzc2lvbihlbmRlZFNlc3Npb24pO1xuICAgIH1cbiAgICBzZXRTZXNzaW9uKG51bGwpO1xuICB9LCBbc2Vzc2lvbl0pO1xuXG4gIC8vIEFkZCBuZXcgY2FyZFxuICBjb25zdCBhZGRDYXJkID0gdXNlQ2FsbGJhY2soKFxuICAgIGNhcmREYXRhOiBPbWl0PEZsYXNoY2FyZCwgJ2lkJyB8ICdzY2hlbWFWZXJzaW9uJyB8ICdjcmVhdGVkQXQnIHwgJ3VwZGF0ZWRBdCc+XG4gICkgPT4ge1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICBjb25zdCBuZXdDYXJkOiBGbGFzaGNhcmQgPSB7XG4gICAgICAuLi5jYXJkRGF0YSxcbiAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxuICAgICAgc2NoZW1hVmVyc2lvbjogJzEuMCcsXG4gICAgICBjcmVhdGVkQXQ6IG5vdyxcbiAgICAgIHVwZGF0ZWRBdDogbm93XG4gICAgfTtcbiAgICBcbiAgICBzYXZlRmxhc2hjYXJkKG5ld0NhcmQpO1xuICAgIFxuICAgIGNvbnN0IHVwZGF0ZWRDYXJkcyA9IFsuLi5jYXJkcywgbmV3Q2FyZF07XG4gICAgc2V0Q2FyZHModXBkYXRlZENhcmRzKTtcbiAgICBcbiAgICAvLyBBZGQgdG8gZHVlIGNhcmRzIGlmIGl0J3MgZHVlXG4gICAgY29uc3QgZHVlID0gZ2V0RHVlQ2FyZHModXBkYXRlZENhcmRzKTtcbiAgICBzZXREdWVDYXJkcyhkdWUpO1xuICB9LCBbY2FyZHNdKTtcblxuICAvLyBBZGQgbXVsdGlwbGUgY2FyZHMgKG1lcmdlIHdpdGhvdXQgZHVwbGljYXRlcylcbiAgY29uc3QgYWRkQ2FyZHMgPSB1c2VDYWxsYmFjaygobmV3Q2FyZHM6IEZsYXNoY2FyZFtdKSA9PiB7XG4gICAgY29uc3QgZXhpc3RpbmdJZHMgPSBuZXcgU2V0KGNhcmRzLm1hcChjID0+IGMuaWQpKTtcbiAgICBcbiAgICAvLyBGaWx0ZXIgb3V0IGNhcmRzIHRoYXQgYWxyZWFkeSBleGlzdCAoYnkgSUQpXG4gICAgLy8gQWxzbyBjaGVjayBmb3IgZHVwbGljYXRlIGNvbnRlbnRcbiAgICBjb25zdCBleGlzdGluZ0NvbnRlbnQgPSBuZXcgU2V0KGNhcmRzLm1hcChjID0+IGMuY29udGVudC5mcm9udC50b0xvd2VyQ2FzZSgpLnRyaW0oKSkpO1xuICAgIFxuICAgIGNvbnN0IHVuaXF1ZU5ld0NhcmRzID0gbmV3Q2FyZHMuZmlsdGVyKG5ld0NhcmQgPT4ge1xuICAgICAgY29uc3QgaXNEdXBsaWNhdGVJZCA9IGV4aXN0aW5nSWRzLmhhcyhuZXdDYXJkLmlkKTtcbiAgICAgIGNvbnN0IGlzRHVwbGljYXRlQ29udGVudCA9IGV4aXN0aW5nQ29udGVudC5oYXMobmV3Q2FyZC5jb250ZW50LmZyb250LnRvTG93ZXJDYXNlKCkudHJpbSgpKTtcbiAgICAgIHJldHVybiAhaXNEdXBsaWNhdGVJZCAmJiAhaXNEdXBsaWNhdGVDb250ZW50O1xuICAgIH0pO1xuXG4gICAgaWYgKHVuaXF1ZU5ld0NhcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5sb2coJ05vIG5ldyB1bmlxdWUgY2FyZHMgdG8gYWRkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTWVyZ2Ugd2l0aCBleGlzdGluZyBjYXJkc1xuICAgIGNvbnN0IG1lcmdlZENhcmRzID0gWy4uLmNhcmRzLCAuLi51bmlxdWVOZXdDYXJkc107XG4gICAgXG4gICAgLy8gU2F2ZSB0byBzdG9yYWdlXG4gICAgc2F2ZUZsYXNoY2FyZHMobWVyZ2VkQ2FyZHMpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBzdGF0ZVxuICAgIHNldENhcmRzKG1lcmdlZENhcmRzKTtcbiAgICBzZXREdWVDYXJkcyhnZXREdWVDYXJkcyhtZXJnZWRDYXJkcykpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGBBZGRlZCAke3VuaXF1ZU5ld0NhcmRzLmxlbmd0aH0gbmV3IGNhcmRzYCk7XG4gIH0sIFtjYXJkc10pO1xuXG4gIHJldHVybiB7XG4gICAgY2FyZHMsXG4gICAgZHVlQ2FyZHMsXG4gICAgY3VycmVudENhcmQsXG4gICAgY3VycmVudEluZGV4LFxuICAgIGlzUmV2ZWFsZWQsXG4gICAgaXNMb2FkaW5nLFxuICAgIHN0YXRzLFxuICAgIHNlc3Npb24sXG4gICAgaW50ZXJ2YWxQcmV2aWV3LFxuICAgIHJldmVhbEFuc3dlcixcbiAgICByYXRlQ2FyZCxcbiAgICBuZXh0Q2FyZCxcbiAgICBwcmV2aW91c0NhcmQsXG4gICAgZ29Ub0NhcmQsXG4gICAgc3RhcnRTZXNzaW9uLFxuICAgIGVuZFNlc3Npb24sXG4gICAgYWRkQ2FyZCxcbiAgICBhZGRDYXJkcyxcbiAgICByZWZyZXNoQ2FyZHNcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwiZ2V0Rmxhc2hjYXJkcyIsInNhdmVGbGFzaGNhcmQiLCJzYXZlRmxhc2hjYXJkcyIsInNlZWRGbGFzaGNhcmRzIiwic2F2ZVNlc3Npb24iLCJzY2hlZHVsZUNhcmQiLCJnZXREdWVDYXJkcyIsImNhbGN1bGF0ZVN0YXRzIiwicHJldmlld1NjaGVkdWxlIiwidXNlRmxhc2hjYXJkcyIsImNhcmRzIiwic2V0Q2FyZHMiLCJkdWVDYXJkcyIsInNldER1ZUNhcmRzIiwiY3VycmVudEluZGV4Iiwic2V0Q3VycmVudEluZGV4IiwiaXNSZXZlYWxlZCIsInNldElzUmV2ZWFsZWQiLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJzZXNzaW9uIiwic2V0U2Vzc2lvbiIsInJldmlld1N0YXJ0VGltZSIsInNldFJldmlld1N0YXJ0VGltZSIsImludGVydmFsUHJldmlldyIsInNldEludGVydmFsUHJldmlldyIsImxvYWRlZENhcmRzIiwiZHVlIiwiY3VycmVudENhcmQiLCJzdGF0cyIsInJlZnJlc2hDYXJkcyIsInJldmVhbEFuc3dlciIsIkRhdGUiLCJub3ciLCJyYXRlQ2FyZCIsInJhdGluZyIsInJlc3VsdCIsInVwZGF0ZWRDYXJkIiwidXBkYXRlZEF0IiwidG9JU09TdHJpbmciLCJzcGFjZWRSZXBldGl0aW9uIiwic3RhdGUiLCJpbnRlcnZhbCIsImVhc2UiLCJyZXBzIiwibGFwc2VzIiwibmV4dFJldmlldyIsImxhc3RSZXZpZXciLCJzdGFiaWxpdHkiLCJkaWZmaWN1bHR5IiwicmV2aWV3UmVjb3JkIiwiY2FyZElkIiwiaWQiLCJyZXZpZXdlZEF0IiwidGltZVNwZW50IiwicHJldmlvdXNTdGF0ZSIsIm5ld1N0YXRlIiwidXBkYXRlZFNlc3Npb24iLCJjYXJkc1Jldmlld2VkIiwiY2FyZHNDb3JyZWN0IiwiY2FyZHNGYWlsZWQiLCJyZXZpZXdzIiwidXBkYXRlZENhcmRzIiwibWFwIiwiYyIsIm5ld0R1ZSIsInNwbGljZSIsInB1c2giLCJmaWx0ZXIiLCJsZW5ndGgiLCJuZXh0Q2FyZCIsInByZXZpb3VzQ2FyZCIsImdvVG9DYXJkIiwiaW5kZXgiLCJzdGFydFNlc3Npb24iLCJuZXdTZXNzaW9uIiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsInN0YXJ0ZWRBdCIsImVuZFNlc3Npb24iLCJlbmRlZFNlc3Npb24iLCJlbmRlZEF0IiwiYWRkQ2FyZCIsImNhcmREYXRhIiwibmV3Q2FyZCIsInNjaGVtYVZlcnNpb24iLCJjcmVhdGVkQXQiLCJhZGRDYXJkcyIsIm5ld0NhcmRzIiwiZXhpc3RpbmdJZHMiLCJTZXQiLCJleGlzdGluZ0NvbnRlbnQiLCJjb250ZW50IiwiZnJvbnQiLCJ0b0xvd2VyQ2FzZSIsInRyaW0iLCJ1bmlxdWVOZXdDYXJkcyIsImlzRHVwbGljYXRlSWQiLCJoYXMiLCJpc0R1cGxpY2F0ZUNvbnRlbnQiLCJjb25zb2xlIiwibG9nIiwibWVyZ2VkQ2FyZHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useFlashcards.ts\n"));

/***/ })

});