"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/import/page",{

/***/ "(app-pages-browser)/./src/hooks/useFlashcards.ts":
/*!************************************!*\
  !*** ./src/hooks/useFlashcards.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFlashcards: function() { return /* binding */ useFlashcards; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_storage_localStorage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/storage/localStorage */ \"(app-pages-browser)/./src/lib/storage/localStorage.ts\");\n/* harmony import */ var _lib_spaced_repetition_fsrs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/spaced-repetition/fsrs */ \"(app-pages-browser)/./src/lib/spaced-repetition/fsrs.ts\");\n/* __next_internal_client_entry_do_not_use__ useFlashcards auto */ \n\n\nconst defaultFilters = {\n    tags: [],\n    systems: [],\n    rotations: [],\n    states: [],\n    difficulties: []\n};\nfunction useFlashcards() {\n    const [cards, setCards] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [dueCards, setDueCards] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [currentIndex, setCurrentIndex] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [isRevealed, setIsRevealed] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [session, setSession] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [reviewStartTime, setReviewStartTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [intervalPreview, setIntervalPreview] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [filters, setFiltersState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultFilters);\n    // Load cards on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        setIsLoading(true);\n        // Seed sample cards if none exist\n        (0,_lib_storage_localStorage__WEBPACK_IMPORTED_MODULE_1__.seedFlashcards)();\n        // Load cards\n        const loadedCards = (0,_lib_storage_localStorage__WEBPACK_IMPORTED_MODULE_1__.getFlashcards)();\n        setCards(loadedCards);\n        // Get due cards\n        const due = (0,_lib_spaced_repetition_fsrs__WEBPACK_IMPORTED_MODULE_2__.getDueCards)(loadedCards);\n        setDueCards(due);\n        // Load saved filters\n        const savedFilters = (0,_lib_storage_localStorage__WEBPACK_IMPORTED_MODULE_1__.getFilters)();\n        if (savedFilters) {\n            setFiltersState(savedFilters);\n        }\n        setIsLoading(false);\n    }, []);\n    // Extract available tags and systems from cards\n    const availableTags = Array.from(new Set(cards.flatMap((c)=>c.metadata.tags))).sort();\n    const availableSystems = Array.from(new Set(cards.map((c)=>c.metadata.system))).sort();\n    // Calculate topic performance\n    const topicPerformance = (()=>{\n        const topicMap = new Map();\n        cards.forEach((card)=>{\n            const key = card.metadata.topic;\n            if (!topicMap.has(key)) {\n                topicMap.set(key, {\n                    system: card.metadata.system,\n                    cards: []\n                });\n            }\n            topicMap.get(key).cards.push(card);\n        });\n        return Array.from(topicMap.entries()).map((param)=>{\n            let [topic, data] = param;\n            const totalCards = data.cards.length;\n            const reviewedCards = data.cards.filter((c)=>c.spacedRepetition.reps > 0);\n            const correctCount = reviewedCards.reduce((sum, c)=>sum + c.spacedRepetition.reps, 0);\n            const incorrectCount = reviewedCards.reduce((sum, c)=>sum + c.spacedRepetition.lapses, 0);\n            const averageEase = reviewedCards.length > 0 ? reviewedCards.reduce((sum, c)=>sum + c.spacedRepetition.ease, 0) / reviewedCards.length : 2.5;\n            const totalAttempts = correctCount + incorrectCount;\n            const retentionRate = totalAttempts > 0 ? correctCount / totalAttempts : 0;\n            let strength;\n            if (reviewedCards.length === 0) {\n                strength = \"new\";\n            } else if (retentionRate >= 0.8) {\n                strength = \"strong\";\n            } else if (retentionRate >= 0.6) {\n                strength = \"moderate\";\n            } else {\n                strength = \"weak\";\n            }\n            return {\n                topic,\n                system: data.system,\n                totalCards,\n                reviewedCards: reviewedCards.length,\n                correctCount,\n                incorrectCount,\n                averageEase,\n                retentionRate,\n                strength\n            };\n        }).sort((a, b)=>a.retentionRate - b.retentionRate); // Weakest first\n    })();\n    // Apply filters to due cards\n    const filteredDueCards = dueCards.filter((card)=>{\n        // If no filters set, show all\n        if (filters.tags.length === 0 && filters.systems.length === 0 && filters.rotations.length === 0 && filters.states.length === 0 && filters.difficulties.length === 0) {\n            return true;\n        }\n        // Check tag filter (card must have at least one matching tag)\n        if (filters.tags.length > 0) {\n            const hasMatchingTag = card.metadata.tags.some((t)=>filters.tags.includes(t));\n            if (!hasMatchingTag) return false;\n        }\n        // Check system filter\n        if (filters.systems.length > 0 && !filters.systems.includes(card.metadata.system)) {\n            return false;\n        }\n        // Check rotation filter\n        if (filters.rotations.length > 0 && card.metadata.rotation && !filters.rotations.includes(card.metadata.rotation)) {\n            return false;\n        }\n        // Check state filter\n        if (filters.states.length > 0 && !filters.states.includes(card.spacedRepetition.state)) {\n            return false;\n        }\n        // Check difficulty filter\n        if (filters.difficulties.length > 0 && !filters.difficulties.includes(card.metadata.difficulty)) {\n            return false;\n        }\n        return true;\n    });\n    // Current card from filtered list\n    const currentCard = filteredDueCards[currentIndex] || null;\n    // Calculate interval preview when card changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (currentCard && isRevealed) {\n            setIntervalPreview((0,_lib_spaced_repetition_fsrs__WEBPACK_IMPORTED_MODULE_2__.previewSchedule)(currentCard));\n        } else {\n            setIntervalPreview(null);\n        }\n    }, [\n        currentCard,\n        isRevealed\n    ]);\n    // Calculate stats\n    const stats = (0,_lib_spaced_repetition_fsrs__WEBPACK_IMPORTED_MODULE_2__.calculateStats)(cards);\n    // Refresh cards from storage\n    const refreshCards = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const loadedCards = (0,_lib_storage_localStorage__WEBPACK_IMPORTED_MODULE_1__.getFlashcards)();\n        setCards(loadedCards);\n        setDueCards((0,_lib_spaced_repetition_fsrs__WEBPACK_IMPORTED_MODULE_2__.getDueCards)(loadedCards));\n    }, []);\n    // Filter actions\n    const setFilters = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((newFilters)=>{\n        setFiltersState(newFilters);\n        (0,_lib_storage_localStorage__WEBPACK_IMPORTED_MODULE_1__.saveFilters)(newFilters);\n        setCurrentIndex(0);\n        setIsRevealed(false);\n    }, []);\n    const clearFilters = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setFilters(defaultFilters);\n    }, [\n        setFilters\n    ]);\n    const toggleTag = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((tag)=>{\n        setFilters({\n            ...filters,\n            tags: filters.tags.includes(tag) ? filters.tags.filter((t)=>t !== tag) : [\n                ...filters.tags,\n                tag\n            ]\n        });\n    }, [\n        filters,\n        setFilters\n    ]);\n    const toggleSystem = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((system)=>{\n        setFilters({\n            ...filters,\n            systems: filters.systems.includes(system) ? filters.systems.filter((s)=>s !== system) : [\n                ...filters.systems,\n                system\n            ]\n        });\n    }, [\n        filters,\n        setFilters\n    ]);\n    // Reveal answer\n    const revealAnswer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setIsRevealed(true);\n        setReviewStartTime(Date.now());\n    }, []);\n    // Rate card and schedule next review\n    const rateCard = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((rating)=>{\n        if (!currentCard) return;\n        // Calculate new scheduling\n        const result = (0,_lib_spaced_repetition_fsrs__WEBPACK_IMPORTED_MODULE_2__.scheduleCard)(currentCard, rating);\n        // Update the card\n        const updatedCard = {\n            ...currentCard,\n            updatedAt: new Date().toISOString(),\n            spacedRepetition: {\n                state: result.state,\n                interval: result.interval,\n                ease: result.ease,\n                reps: currentCard.spacedRepetition.reps + (rating !== \"again\" ? 1 : 0),\n                lapses: currentCard.spacedRepetition.lapses + (rating === \"again\" ? 1 : 0),\n                nextReview: result.nextReview.toISOString(),\n                lastReview: new Date().toISOString(),\n                stability: result.stability,\n                difficulty: result.difficulty\n            }\n        };\n        // Save to storage\n        (0,_lib_storage_localStorage__WEBPACK_IMPORTED_MODULE_1__.saveFlashcard)(updatedCard);\n        // Update session if active\n        if (session && reviewStartTime) {\n            const reviewRecord = {\n                cardId: currentCard.id,\n                rating,\n                reviewedAt: new Date().toISOString(),\n                timeSpent: Date.now() - reviewStartTime,\n                previousState: currentCard.spacedRepetition.state,\n                newState: result.state\n            };\n            const updatedSession = {\n                ...session,\n                cardsReviewed: session.cardsReviewed + 1,\n                cardsCorrect: session.cardsCorrect + (rating !== \"again\" ? 1 : 0),\n                cardsFailed: session.cardsFailed + (rating === \"again\" ? 1 : 0),\n                reviews: [\n                    ...session.reviews,\n                    reviewRecord\n                ]\n            };\n            setSession(updatedSession);\n            (0,_lib_storage_localStorage__WEBPACK_IMPORTED_MODULE_1__.saveSession)(updatedSession);\n        }\n        // Update local state\n        const updatedCards = cards.map((c)=>c.id === updatedCard.id ? updatedCard : c);\n        setCards(updatedCards);\n        // Remove from due cards if no longer due (or move to end if still learning)\n        if (result.state === \"learning\" || result.state === \"relearning\") {\n            // Keep in queue but move to end\n            const newDue = [\n                ...dueCards\n            ];\n            const idx = newDue.findIndex((c)=>c.id === currentCard.id);\n            if (idx >= 0) {\n                newDue.splice(idx, 1);\n                newDue.push(updatedCard);\n            }\n            setDueCards(newDue);\n        } else {\n            // Remove from due cards\n            const newDue = dueCards.filter((c)=>c.id !== currentCard.id);\n            setDueCards(newDue);\n            // Adjust index if needed\n            if (currentIndex >= filteredDueCards.length - 1 && filteredDueCards.length > 1) {\n                setCurrentIndex(Math.max(0, currentIndex - 1));\n            }\n        }\n        // Reset for next card\n        setIsRevealed(false);\n        setReviewStartTime(null);\n    }, [\n        currentCard,\n        cards,\n        dueCards,\n        filteredDueCards,\n        currentIndex,\n        session,\n        reviewStartTime\n    ]);\n    // Navigation\n    const nextCard = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (currentIndex < filteredDueCards.length - 1) {\n            setCurrentIndex(currentIndex + 1);\n            setIsRevealed(false);\n        }\n    }, [\n        currentIndex,\n        filteredDueCards.length\n    ]);\n    const previousCard = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (currentIndex > 0) {\n            setCurrentIndex(currentIndex - 1);\n            setIsRevealed(false);\n        }\n    }, [\n        currentIndex\n    ]);\n    const goToCard = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((index)=>{\n        if (index >= 0 && index < filteredDueCards.length) {\n            setCurrentIndex(index);\n            setIsRevealed(false);\n        }\n    }, [\n        filteredDueCards.length\n    ]);\n    // Session management\n    const startSession = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const newSession = {\n            id: crypto.randomUUID(),\n            startedAt: new Date().toISOString(),\n            cardsReviewed: 0,\n            cardsCorrect: 0,\n            cardsFailed: 0,\n            reviews: []\n        };\n        setSession(newSession);\n        setCurrentIndex(0);\n        setIsRevealed(false);\n    }, []);\n    const endSession = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (session) {\n            const endedSession = {\n                ...session,\n                endedAt: new Date().toISOString()\n            };\n            (0,_lib_storage_localStorage__WEBPACK_IMPORTED_MODULE_1__.saveSession)(endedSession);\n        }\n        setSession(null);\n    }, [\n        session\n    ]);\n    // Add new card\n    const addCard = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((cardData)=>{\n        const now = new Date().toISOString();\n        const newCard = {\n            ...cardData,\n            id: crypto.randomUUID(),\n            schemaVersion: \"1.0\",\n            createdAt: now,\n            updatedAt: now\n        };\n        (0,_lib_storage_localStorage__WEBPACK_IMPORTED_MODULE_1__.saveFlashcard)(newCard);\n        const updatedCards = [\n            ...cards,\n            newCard\n        ];\n        setCards(updatedCards);\n        // Add to due cards if it's due\n        const due = (0,_lib_spaced_repetition_fsrs__WEBPACK_IMPORTED_MODULE_2__.getDueCards)(updatedCards);\n        setDueCards(due);\n    }, [\n        cards\n    ]);\n    // Add multiple cards (merge without duplicates)\n    const addCards = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((newCards)=>{\n        const existingIds = new Set(cards.map((c)=>c.id));\n        // Filter out cards that already exist (by ID)\n        // Also check for duplicate content\n        const existingContent = new Set(cards.map((c)=>c.content.front.toLowerCase().trim()));\n        const uniqueNewCards = newCards.filter((newCard)=>{\n            const isDuplicateId = existingIds.has(newCard.id);\n            const isDuplicateContent = existingContent.has(newCard.content.front.toLowerCase().trim());\n            return !isDuplicateId && !isDuplicateContent;\n        });\n        if (uniqueNewCards.length === 0) {\n            console.log(\"No new unique cards to add\");\n            return;\n        }\n        // Merge with existing cards\n        const mergedCards = [\n            ...cards,\n            ...uniqueNewCards\n        ];\n        // Save to storage\n        (0,_lib_storage_localStorage__WEBPACK_IMPORTED_MODULE_1__.saveFlashcards)(mergedCards);\n        // Update state\n        setCards(mergedCards);\n        setDueCards((0,_lib_spaced_repetition_fsrs__WEBPACK_IMPORTED_MODULE_2__.getDueCards)(mergedCards));\n        console.log(\"Added \".concat(uniqueNewCards.length, \" new cards\"));\n    }, [\n        cards\n    ]);\n    // Update existing card\n    const updateCard = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((updatedCard)=>{\n        const updated = {\n            ...updatedCard,\n            updatedAt: new Date().toISOString()\n        };\n        (0,_lib_storage_localStorage__WEBPACK_IMPORTED_MODULE_1__.saveFlashcard)(updated);\n        const updatedCards = cards.map((c)=>c.id === updated.id ? updated : c);\n        setCards(updatedCards);\n        setDueCards((0,_lib_spaced_repetition_fsrs__WEBPACK_IMPORTED_MODULE_2__.getDueCards)(updatedCards));\n    }, [\n        cards\n    ]);\n    // Delete card\n    const deleteCard = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id)=>{\n        const updatedCards = cards.filter((c)=>c.id !== id);\n        (0,_lib_storage_localStorage__WEBPACK_IMPORTED_MODULE_1__.saveFlashcards)(updatedCards);\n        setCards(updatedCards);\n        setDueCards((0,_lib_spaced_repetition_fsrs__WEBPACK_IMPORTED_MODULE_2__.getDueCards)(updatedCards));\n    }, [\n        cards\n    ]);\n    return {\n        cards,\n        dueCards,\n        filteredDueCards,\n        currentCard,\n        currentIndex,\n        isRevealed,\n        isLoading,\n        stats,\n        session,\n        intervalPreview,\n        filters,\n        availableTags,\n        availableSystems,\n        topicPerformance,\n        revealAnswer,\n        rateCard,\n        nextCard,\n        previousCard,\n        goToCard,\n        startSession,\n        endSession,\n        addCard,\n        addCards,\n        updateCard,\n        deleteCard,\n        refreshCards,\n        setFilters,\n        clearFilters,\n        toggleTag,\n        toggleSystem\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VGbGFzaGNhcmRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O21FQUV5RDtBQVVyQjtBQU1FO0FBMEN0QyxNQUFNYyxpQkFBNkI7SUFDakNDLE1BQU0sRUFBRTtJQUNSQyxTQUFTLEVBQUU7SUFDWEMsV0FBVyxFQUFFO0lBQ2JDLFFBQVEsRUFBRTtJQUNWQyxjQUFjLEVBQUU7QUFDbEI7QUFFTyxTQUFTQztJQUNkLE1BQU0sQ0FBQ0MsT0FBT0MsU0FBUyxHQUFHdEIsK0NBQVFBLENBQWMsRUFBRTtJQUNsRCxNQUFNLENBQUN1QixVQUFVQyxZQUFZLEdBQUd4QiwrQ0FBUUEsQ0FBYyxFQUFFO0lBQ3hELE1BQU0sQ0FBQ3lCLGNBQWNDLGdCQUFnQixHQUFHMUIsK0NBQVFBLENBQUM7SUFDakQsTUFBTSxDQUFDMkIsWUFBWUMsY0FBYyxHQUFHNUIsK0NBQVFBLENBQUM7SUFDN0MsTUFBTSxDQUFDNkIsV0FBV0MsYUFBYSxHQUFHOUIsK0NBQVFBLENBQUM7SUFDM0MsTUFBTSxDQUFDK0IsU0FBU0MsV0FBVyxHQUFHaEMsK0NBQVFBLENBQXVCO0lBQzdELE1BQU0sQ0FBQ2lDLGlCQUFpQkMsbUJBQW1CLEdBQUdsQywrQ0FBUUEsQ0FBZ0I7SUFDdEUsTUFBTSxDQUFDbUMsaUJBQWlCQyxtQkFBbUIsR0FBR3BDLCtDQUFRQSxDQUFnQztJQUN0RixNQUFNLENBQUNxQyxTQUFTQyxnQkFBZ0IsR0FBR3RDLCtDQUFRQSxDQUFhYztJQUV4RCxzQkFBc0I7SUFDdEJiLGdEQUFTQSxDQUFDO1FBQ1I2QixhQUFhO1FBRWIsa0NBQWtDO1FBQ2xDeEIseUVBQWNBO1FBRWQsYUFBYTtRQUNiLE1BQU1pQyxjQUFjcEMsd0VBQWFBO1FBQ2pDbUIsU0FBU2lCO1FBRVQsZ0JBQWdCO1FBQ2hCLE1BQU1DLE1BQU03Qix3RUFBV0EsQ0FBQzRCO1FBQ3hCZixZQUFZZ0I7UUFFWixxQkFBcUI7UUFDckIsTUFBTUMsZUFBZWpDLHFFQUFV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QUFjQSxDQUFDMEg7UUFDZnpHLFNBQVN5RztRQUNUdkcsWUFBWWIsd0VBQVdBLENBQUNvSDtJQUMxQixHQUFHO1FBQUMxRztLQUFNO0lBRVYsT0FBTztRQUNMQTtRQUNBRTtRQUNBNkQ7UUFDQVE7UUFDQW5FO1FBQ0FFO1FBQ0FFO1FBQ0FnRTtRQUNBOUQ7UUFDQUk7UUFDQUU7UUFDQUs7UUFDQVE7UUFDQUc7UUFDQWlEO1FBQ0FHO1FBQ0E2QjtRQUNBQztRQUNBQztRQUNBRTtRQUNBSztRQUNBRztRQUNBSztRQUNBYztRQUNBRTtRQUNBekU7UUFDQUM7UUFDQUU7UUFDQUM7UUFDQUU7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9ob29rcy91c2VGbGFzaGNhcmRzLnRzPzk0ZGEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB0eXBlIHsgRmxhc2hjYXJkLCBSYXRpbmcsIFJldmlld1Nlc3Npb24sIFJldmlld1JlY29yZCwgRGVja0ZpbHRlciwgVG9waWNQZXJmb3JtYW5jZSwgTWVkaWNhbFN5c3RlbSB9IGZyb20gJ0AvdHlwZXMnO1xuaW1wb3J0IHsgXG4gIGdldEZsYXNoY2FyZHMsIFxuICBzYXZlRmxhc2hjYXJkLCBcbiAgc2F2ZUZsYXNoY2FyZHMsXG4gIHNlZWRGbGFzaGNhcmRzLFxuICBzYXZlU2Vzc2lvbixcbiAgZ2V0RmlsdGVycyxcbiAgc2F2ZUZpbHRlcnNcbn0gZnJvbSAnQC9saWIvc3RvcmFnZS9sb2NhbFN0b3JhZ2UnO1xuaW1wb3J0IHsgXG4gIHNjaGVkdWxlQ2FyZCwgXG4gIGdldER1ZUNhcmRzLCBcbiAgY2FsY3VsYXRlU3RhdHMsXG4gIHByZXZpZXdTY2hlZHVsZSBcbn0gZnJvbSAnQC9saWIvc3BhY2VkLXJlcGV0aXRpb24vZnNycyc7XG5cbmludGVyZmFjZSBVc2VGbGFzaGNhcmRzUmV0dXJuIHtcbiAgLy8gU3RhdGVcbiAgY2FyZHM6IEZsYXNoY2FyZFtdO1xuICBkdWVDYXJkczogRmxhc2hjYXJkW107XG4gIGZpbHRlcmVkRHVlQ2FyZHM6IEZsYXNoY2FyZFtdO1xuICBjdXJyZW50Q2FyZDogRmxhc2hjYXJkIHwgbnVsbDtcbiAgY3VycmVudEluZGV4OiBudW1iZXI7XG4gIGlzUmV2ZWFsZWQ6IGJvb2xlYW47XG4gIGlzTG9hZGluZzogYm9vbGVhbjtcbiAgc3RhdHM6IFJldHVyblR5cGU8dHlwZW9mIGNhbGN1bGF0ZVN0YXRzPjtcbiAgc2Vzc2lvbjogUmV2aWV3U2Vzc2lvbiB8IG51bGw7XG4gIGludGVydmFsUHJldmlldzogUmVjb3JkPFJhdGluZywgbnVtYmVyPiB8IG51bGw7XG4gIFxuICAvLyBGaWx0ZXIgc3RhdGVcbiAgZmlsdGVyczogRGVja0ZpbHRlcjtcbiAgYXZhaWxhYmxlVGFnczogc3RyaW5nW107XG4gIGF2YWlsYWJsZVN5c3RlbXM6IE1lZGljYWxTeXN0ZW1bXTtcbiAgdG9waWNQZXJmb3JtYW5jZTogVG9waWNQZXJmb3JtYW5jZVtdO1xuICBcbiAgLy8gQWN0aW9uc1xuICByZXZlYWxBbnN3ZXI6ICgpID0+IHZvaWQ7XG4gIHJhdGVDYXJkOiAocmF0aW5nOiBSYXRpbmcpID0+IHZvaWQ7XG4gIG5leHRDYXJkOiAoKSA9PiB2b2lkO1xuICBwcmV2aW91c0NhcmQ6ICgpID0+IHZvaWQ7XG4gIGdvVG9DYXJkOiAoaW5kZXg6IG51bWJlcikgPT4gdm9pZDtcbiAgc3RhcnRTZXNzaW9uOiAoKSA9PiB2b2lkO1xuICBlbmRTZXNzaW9uOiAoKSA9PiB2b2lkO1xuICBhZGRDYXJkOiAoY2FyZDogT21pdDxGbGFzaGNhcmQsICdpZCcgfCAnc2NoZW1hVmVyc2lvbicgfCAnY3JlYXRlZEF0JyB8ICd1cGRhdGVkQXQnPikgPT4gdm9pZDtcbiAgYWRkQ2FyZHM6IChjYXJkczogRmxhc2hjYXJkW10pID0+IHZvaWQ7XG4gIHVwZGF0ZUNhcmQ6IChjYXJkOiBGbGFzaGNhcmQpID0+IHZvaWQ7XG4gIGRlbGV0ZUNhcmQ6IChpZDogc3RyaW5nKSA9PiB2b2lkO1xuICByZWZyZXNoQ2FyZHM6ICgpID0+IHZvaWQ7XG4gIFxuICAvLyBGaWx0ZXIgYWN0aW9uc1xuICBzZXRGaWx0ZXJzOiAoZmlsdGVyczogRGVja0ZpbHRlcikgPT4gdm9pZDtcbiAgY2xlYXJGaWx0ZXJzOiAoKSA9PiB2b2lkO1xuICB0b2dnbGVUYWc6ICh0YWc6IHN0cmluZykgPT4gdm9pZDtcbiAgdG9nZ2xlU3lzdGVtOiAoc3lzdGVtOiBNZWRpY2FsU3lzdGVtKSA9PiB2b2lkO1xufVxuXG5jb25zdCBkZWZhdWx0RmlsdGVyczogRGVja0ZpbHRlciA9IHtcbiAgdGFnczogW10sXG4gIHN5c3RlbXM6IFtdLFxuICByb3RhdGlvbnM6IFtdLFxuICBzdGF0ZXM6IFtdLFxuICBkaWZmaWN1bHRpZXM6IFtdXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlRmxhc2hjYXJkcygpOiBVc2VGbGFzaGNhcmRzUmV0dXJuIHtcbiAgY29uc3QgW2NhcmRzLCBzZXRDYXJkc10gPSB1c2VTdGF0ZTxGbGFzaGNhcmRbXT4oW10pO1xuICBjb25zdCBbZHVlQ2FyZHMsIHNldER1ZUNhcmRzXSA9IHVzZVN0YXRlPEZsYXNoY2FyZFtdPihbXSk7XG4gIGNvbnN0IFtjdXJyZW50SW5kZXgsIHNldEN1cnJlbnRJbmRleF0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW2lzUmV2ZWFsZWQsIHNldElzUmV2ZWFsZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtzZXNzaW9uLCBzZXRTZXNzaW9uXSA9IHVzZVN0YXRlPFJldmlld1Nlc3Npb24gfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3Jldmlld1N0YXJ0VGltZSwgc2V0UmV2aWV3U3RhcnRUaW1lXSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbaW50ZXJ2YWxQcmV2aWV3LCBzZXRJbnRlcnZhbFByZXZpZXddID0gdXNlU3RhdGU8UmVjb3JkPFJhdGluZywgbnVtYmVyPiB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbZmlsdGVycywgc2V0RmlsdGVyc1N0YXRlXSA9IHVzZVN0YXRlPERlY2tGaWx0ZXI+KGRlZmF1bHRGaWx0ZXJzKTtcblxuICAvLyBMb2FkIGNhcmRzIG9uIG1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgIFxuICAgIC8vIFNlZWQgc2FtcGxlIGNhcmRzIGlmIG5vbmUgZXhpc3RcbiAgICBzZWVkRmxhc2hjYXJkcygpO1xuICAgIFxuICAgIC8vIExvYWQgY2FyZHNcbiAgICBjb25zdCBsb2FkZWRDYXJkcyA9IGdldEZsYXNoY2FyZHMoKTtcbiAgICBzZXRDYXJkcyhsb2FkZWRDYXJkcyk7XG4gICAgXG4gICAgLy8gR2V0IGR1ZSBjYXJkc1xuICAgIGNvbnN0IGR1ZSA9IGdldER1ZUNhcmRzKGxvYWRlZENhcmRzKTtcbiAgICBzZXREdWVDYXJkcyhkdWUpO1xuICAgIFxuICAgIC8vIExvYWQgc2F2ZWQgZmlsdGVyc1xuICAgIGNvbnN0IHNhdmVkRmlsdGVycyA9IGdldEZpbHRlcnMoKTtcbiAgICBpZiAoc2F2ZWRGaWx0ZXJzKSB7XG4gICAgICBzZXRGaWx0ZXJzU3RhdGUoc2F2ZWRGaWx0ZXJzKTtcbiAgICB9XG4gICAgXG4gICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgfSwgW10pO1xuXG4gIC8vIEV4dHJhY3QgYXZhaWxhYmxlIHRhZ3MgYW5kIHN5c3RlbXMgZnJvbSBjYXJkc1xuICBjb25zdCBhdmFpbGFibGVUYWdzID0gQXJyYXkuZnJvbShcbiAgICBuZXcgU2V0KGNhcmRzLmZsYXRNYXAoYyA9PiBjLm1ldGFkYXRhLnRhZ3MpKVxuICApLnNvcnQoKTtcbiAgXG4gIGNvbnN0IGF2YWlsYWJsZVN5c3RlbXMgPSBBcnJheS5mcm9tKFxuICAgIG5ldyBTZXQoY2FyZHMubWFwKGMgPT4gYy5tZXRhZGF0YS5zeXN0ZW0pKVxuICApLnNvcnQoKSBhcyBNZWRpY2FsU3lzdGVtW107XG5cbiAgLy8gQ2FsY3VsYXRlIHRvcGljIHBlcmZvcm1hbmNlXG4gIGNvbnN0IHRvcGljUGVyZm9ybWFuY2U6IFRvcGljUGVyZm9ybWFuY2VbXSA9ICgoKSA9PiB7XG4gICAgY29uc3QgdG9waWNNYXAgPSBuZXcgTWFwPHN0cmluZywge1xuICAgICAgc3lzdGVtOiBNZWRpY2FsU3lzdGVtO1xuICAgICAgY2FyZHM6IEZsYXNoY2FyZFtdO1xuICAgIH0+KCk7XG4gICAgXG4gICAgY2FyZHMuZm9yRWFjaChjYXJkID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IGNhcmQubWV0YWRhdGEudG9waWM7XG4gICAgICBpZiAoIXRvcGljTWFwLmhhcyhrZXkpKSB7XG4gICAgICAgIHRvcGljTWFwLnNldChrZXksIHsgc3lzdGVtOiBjYXJkLm1ldGFkYXRhLnN5c3RlbSwgY2FyZHM6IFtdIH0pO1xuICAgICAgfVxuICAgICAgdG9waWNNYXAuZ2V0KGtleSkhLmNhcmRzLnB1c2goY2FyZCk7XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIEFycmF5LmZyb20odG9waWNNYXAuZW50cmllcygpKS5tYXAoKFt0b3BpYywgZGF0YV0pID0+IHtcbiAgICAgIGNvbnN0IHRvdGFsQ2FyZHMgPSBkYXRhLmNhcmRzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHJldmlld2VkQ2FyZHMgPSBkYXRhLmNhcmRzLmZpbHRlcihjID0+IGMuc3BhY2VkUmVwZXRpdGlvbi5yZXBzID4gMCk7XG4gICAgICBjb25zdCBjb3JyZWN0Q291bnQgPSByZXZpZXdlZENhcmRzLnJlZHVjZSgoc3VtLCBjKSA9PiBzdW0gKyBjLnNwYWNlZFJlcGV0aXRpb24ucmVwcywgMCk7XG4gICAgICBjb25zdCBpbmNvcnJlY3RDb3VudCA9IHJldmlld2VkQ2FyZHMucmVkdWNlKChzdW0sIGMpID0+IHN1bSArIGMuc3BhY2VkUmVwZXRpdGlvbi5sYXBzZXMsIDApO1xuICAgICAgY29uc3QgYXZlcmFnZUVhc2UgPSByZXZpZXdlZENhcmRzLmxlbmd0aCA+IDAgXG4gICAgICAgID8gcmV2aWV3ZWRDYXJkcy5yZWR1Y2UoKHN1bSwgYykgPT4gc3VtICsgYy5zcGFjZWRSZXBldGl0aW9uLmVhc2UsIDApIC8gcmV2aWV3ZWRDYXJkcy5sZW5ndGggXG4gICAgICAgIDogMi41O1xuICAgICAgXG4gICAgICBjb25zdCB0b3RhbEF0dGVtcHRzID0gY29ycmVjdENvdW50ICsgaW5jb3JyZWN0Q291bnQ7XG4gICAgICBjb25zdCByZXRlbnRpb25SYXRlID0gdG90YWxBdHRlbXB0cyA+IDAgPyBjb3JyZWN0Q291bnQgLyB0b3RhbEF0dGVtcHRzIDogMDtcbiAgICAgIFxuICAgICAgbGV0IHN0cmVuZ3RoOiAnc3Ryb25nJyB8ICdtb2RlcmF0ZScgfCAnd2VhaycgfCAnbmV3JztcbiAgICAgIGlmIChyZXZpZXdlZENhcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdHJlbmd0aCA9ICduZXcnO1xuICAgICAgfSBlbHNlIGlmIChyZXRlbnRpb25SYXRlID49IDAuOCkge1xuICAgICAgICBzdHJlbmd0aCA9ICdzdHJvbmcnO1xuICAgICAgfSBlbHNlIGlmIChyZXRlbnRpb25SYXRlID49IDAuNikge1xuICAgICAgICBzdHJlbmd0aCA9ICdtb2RlcmF0ZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlbmd0aCA9ICd3ZWFrJztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9waWMsXG4gICAgICAgIHN5c3RlbTogZGF0YS5zeXN0ZW0sXG4gICAgICAgIHRvdGFsQ2FyZHMsXG4gICAgICAgIHJldmlld2VkQ2FyZHM6IHJldmlld2VkQ2FyZHMubGVuZ3RoLFxuICAgICAgICBjb3JyZWN0Q291bnQsXG4gICAgICAgIGluY29ycmVjdENvdW50LFxuICAgICAgICBhdmVyYWdlRWFzZSxcbiAgICAgICAgcmV0ZW50aW9uUmF0ZSxcbiAgICAgICAgc3RyZW5ndGhcbiAgICAgIH07XG4gICAgfSkuc29ydCgoYSwgYikgPT4gYS5yZXRlbnRpb25SYXRlIC0gYi5yZXRlbnRpb25SYXRlKTsgLy8gV2Vha2VzdCBmaXJzdFxuICB9KSgpO1xuXG4gIC8vIEFwcGx5IGZpbHRlcnMgdG8gZHVlIGNhcmRzXG4gIGNvbnN0IGZpbHRlcmVkRHVlQ2FyZHMgPSBkdWVDYXJkcy5maWx0ZXIoY2FyZCA9PiB7XG4gICAgLy8gSWYgbm8gZmlsdGVycyBzZXQsIHNob3cgYWxsXG4gICAgaWYgKFxuICAgICAgZmlsdGVycy50YWdzLmxlbmd0aCA9PT0gMCAmJiBcbiAgICAgIGZpbHRlcnMuc3lzdGVtcy5sZW5ndGggPT09IDAgJiYgXG4gICAgICBmaWx0ZXJzLnJvdGF0aW9ucy5sZW5ndGggPT09IDAgJiZcbiAgICAgIGZpbHRlcnMuc3RhdGVzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgZmlsdGVycy5kaWZmaWN1bHRpZXMubGVuZ3RoID09PSAwXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgdGFnIGZpbHRlciAoY2FyZCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIG1hdGNoaW5nIHRhZylcbiAgICBpZiAoZmlsdGVycy50YWdzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGhhc01hdGNoaW5nVGFnID0gY2FyZC5tZXRhZGF0YS50YWdzLnNvbWUodCA9PiBmaWx0ZXJzLnRhZ3MuaW5jbHVkZXModCkpO1xuICAgICAgaWYgKCFoYXNNYXRjaGluZ1RhZykgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBzeXN0ZW0gZmlsdGVyXG4gICAgaWYgKGZpbHRlcnMuc3lzdGVtcy5sZW5ndGggPiAwICYmICFmaWx0ZXJzLnN5c3RlbXMuaW5jbHVkZXMoY2FyZC5tZXRhZGF0YS5zeXN0ZW0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIHJvdGF0aW9uIGZpbHRlclxuICAgIGlmIChmaWx0ZXJzLnJvdGF0aW9ucy5sZW5ndGggPiAwICYmIGNhcmQubWV0YWRhdGEucm90YXRpb24gJiYgIWZpbHRlcnMucm90YXRpb25zLmluY2x1ZGVzKGNhcmQubWV0YWRhdGEucm90YXRpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIHN0YXRlIGZpbHRlclxuICAgIGlmIChmaWx0ZXJzLnN0YXRlcy5sZW5ndGggPiAwICYmICFmaWx0ZXJzLnN0YXRlcy5pbmNsdWRlcyhjYXJkLnNwYWNlZFJlcGV0aXRpb24uc3RhdGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGRpZmZpY3VsdHkgZmlsdGVyXG4gICAgaWYgKGZpbHRlcnMuZGlmZmljdWx0aWVzLmxlbmd0aCA+IDAgJiYgIWZpbHRlcnMuZGlmZmljdWx0aWVzLmluY2x1ZGVzKGNhcmQubWV0YWRhdGEuZGlmZmljdWx0eSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuXG4gIC8vIEN1cnJlbnQgY2FyZCBmcm9tIGZpbHRlcmVkIGxpc3RcbiAgY29uc3QgY3VycmVudENhcmQgPSBmaWx0ZXJlZER1ZUNhcmRzW2N1cnJlbnRJbmRleF0gfHwgbnVsbDtcblxuICAvLyBDYWxjdWxhdGUgaW50ZXJ2YWwgcHJldmlldyB3aGVuIGNhcmQgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjdXJyZW50Q2FyZCAmJiBpc1JldmVhbGVkKSB7XG4gICAgICBzZXRJbnRlcnZhbFByZXZpZXcocHJldmlld1NjaGVkdWxlKGN1cnJlbnRDYXJkKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEludGVydmFsUHJldmlldyhudWxsKTtcbiAgICB9XG4gIH0sIFtjdXJyZW50Q2FyZCwgaXNSZXZlYWxlZF0pO1xuXG4gIC8vIENhbGN1bGF0ZSBzdGF0c1xuICBjb25zdCBzdGF0cyA9IGNhbGN1bGF0ZVN0YXRzKGNhcmRzKTtcblxuICAvLyBSZWZyZXNoIGNhcmRzIGZyb20gc3RvcmFnZVxuICBjb25zdCByZWZyZXNoQ2FyZHMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgbG9hZGVkQ2FyZHMgPSBnZXRGbGFzaGNhcmRzKCk7XG4gICAgc2V0Q2FyZHMobG9hZGVkQ2FyZHMpO1xuICAgIHNldER1ZUNhcmRzKGdldER1ZUNhcmRzKGxvYWRlZENhcmRzKSk7XG4gIH0sIFtdKTtcblxuICAvLyBGaWx0ZXIgYWN0aW9uc1xuICBjb25zdCBzZXRGaWx0ZXJzID0gdXNlQ2FsbGJhY2soKG5ld0ZpbHRlcnM6IERlY2tGaWx0ZXIpID0+IHtcbiAgICBzZXRGaWx0ZXJzU3RhdGUobmV3RmlsdGVycyk7XG4gICAgc2F2ZUZpbHRlcnMobmV3RmlsdGVycyk7XG4gICAgc2V0Q3VycmVudEluZGV4KDApO1xuICAgIHNldElzUmV2ZWFsZWQoZmFsc2UpO1xuICB9LCBbXSk7XG4gIFxuICBjb25zdCBjbGVhckZpbHRlcnMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0RmlsdGVycyhkZWZhdWx0RmlsdGVycyk7XG4gIH0sIFtzZXRGaWx0ZXJzXSk7XG4gIFxuICBjb25zdCB0b2dnbGVUYWcgPSB1c2VDYWxsYmFjaygodGFnOiBzdHJpbmcpID0+IHtcbiAgICBzZXRGaWx0ZXJzKHtcbiAgICAgIC4uLmZpbHRlcnMsXG4gICAgICB0YWdzOiBmaWx0ZXJzLnRhZ3MuaW5jbHVkZXModGFnKSBcbiAgICAgICAgPyBmaWx0ZXJzLnRhZ3MuZmlsdGVyKHQgPT4gdCAhPT0gdGFnKVxuICAgICAgICA6IFsuLi5maWx0ZXJzLnRhZ3MsIHRhZ11cbiAgICB9KTtcbiAgfSwgW2ZpbHRlcnMsIHNldEZpbHRlcnNdKTtcbiAgXG4gIGNvbnN0IHRvZ2dsZVN5c3RlbSA9IHVzZUNhbGxiYWNrKChzeXN0ZW06IE1lZGljYWxTeXN0ZW0pID0+IHtcbiAgICBzZXRGaWx0ZXJzKHtcbiAgICAgIC4uLmZpbHRlcnMsXG4gICAgICBzeXN0ZW1zOiBmaWx0ZXJzLnN5c3RlbXMuaW5jbHVkZXMoc3lzdGVtKVxuICAgICAgICA/IGZpbHRlcnMuc3lzdGVtcy5maWx0ZXIocyA9PiBzICE9PSBzeXN0ZW0pXG4gICAgICAgIDogWy4uLmZpbHRlcnMuc3lzdGVtcywgc3lzdGVtXVxuICAgIH0pO1xuICB9LCBbZmlsdGVycywgc2V0RmlsdGVyc10pO1xuXG4gIC8vIFJldmVhbCBhbnN3ZXJcbiAgY29uc3QgcmV2ZWFsQW5zd2VyID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldElzUmV2ZWFsZWQodHJ1ZSk7XG4gICAgc2V0UmV2aWV3U3RhcnRUaW1lKERhdGUubm93KCkpO1xuICB9LCBbXSk7XG5cbiAgLy8gUmF0ZSBjYXJkIGFuZCBzY2hlZHVsZSBuZXh0IHJldmlld1xuICBjb25zdCByYXRlQ2FyZCA9IHVzZUNhbGxiYWNrKChyYXRpbmc6IFJhdGluZykgPT4ge1xuICAgIGlmICghY3VycmVudENhcmQpIHJldHVybjtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgbmV3IHNjaGVkdWxpbmdcbiAgICBjb25zdCByZXN1bHQgPSBzY2hlZHVsZUNhcmQoY3VycmVudENhcmQsIHJhdGluZyk7XG4gICAgXG4gICAgLy8gVXBkYXRlIHRoZSBjYXJkXG4gICAgY29uc3QgdXBkYXRlZENhcmQ6IEZsYXNoY2FyZCA9IHtcbiAgICAgIC4uLmN1cnJlbnRDYXJkLFxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBzcGFjZWRSZXBldGl0aW9uOiB7XG4gICAgICAgIHN0YXRlOiByZXN1bHQuc3RhdGUsXG4gICAgICAgIGludGVydmFsOiByZXN1bHQuaW50ZXJ2YWwsXG4gICAgICAgIGVhc2U6IHJlc3VsdC5lYXNlLFxuICAgICAgICByZXBzOiBjdXJyZW50Q2FyZC5zcGFjZWRSZXBldGl0aW9uLnJlcHMgKyAocmF0aW5nICE9PSAnYWdhaW4nID8gMSA6IDApLFxuICAgICAgICBsYXBzZXM6IGN1cnJlbnRDYXJkLnNwYWNlZFJlcGV0aXRpb24ubGFwc2VzICsgKHJhdGluZyA9PT0gJ2FnYWluJyA/IDEgOiAwKSxcbiAgICAgICAgbmV4dFJldmlldzogcmVzdWx0Lm5leHRSZXZpZXcudG9JU09TdHJpbmcoKSxcbiAgICAgICAgbGFzdFJldmlldzogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBzdGFiaWxpdHk6IHJlc3VsdC5zdGFiaWxpdHksXG4gICAgICAgIGRpZmZpY3VsdHk6IHJlc3VsdC5kaWZmaWN1bHR5XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvLyBTYXZlIHRvIHN0b3JhZ2VcbiAgICBzYXZlRmxhc2hjYXJkKHVwZGF0ZWRDYXJkKTtcbiAgICBcbiAgICAvLyBVcGRhdGUgc2Vzc2lvbiBpZiBhY3RpdmVcbiAgICBpZiAoc2Vzc2lvbiAmJiByZXZpZXdTdGFydFRpbWUpIHtcbiAgICAgIGNvbnN0IHJldmlld1JlY29yZDogUmV2aWV3UmVjb3JkID0ge1xuICAgICAgICBjYXJkSWQ6IGN1cnJlbnRDYXJkLmlkLFxuICAgICAgICByYXRpbmcsXG4gICAgICAgIHJldmlld2VkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdGltZVNwZW50OiBEYXRlLm5vdygpIC0gcmV2aWV3U3RhcnRUaW1lLFxuICAgICAgICBwcmV2aW91c1N0YXRlOiBjdXJyZW50Q2FyZC5zcGFjZWRSZXBldGl0aW9uLnN0YXRlLFxuICAgICAgICBuZXdTdGF0ZTogcmVzdWx0LnN0YXRlXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCB1cGRhdGVkU2Vzc2lvbjogUmV2aWV3U2Vzc2lvbiA9IHtcbiAgICAgICAgLi4uc2Vzc2lvbixcbiAgICAgICAgY2FyZHNSZXZpZXdlZDogc2Vzc2lvbi5jYXJkc1Jldmlld2VkICsgMSxcbiAgICAgICAgY2FyZHNDb3JyZWN0OiBzZXNzaW9uLmNhcmRzQ29ycmVjdCArIChyYXRpbmcgIT09ICdhZ2FpbicgPyAxIDogMCksXG4gICAgICAgIGNhcmRzRmFpbGVkOiBzZXNzaW9uLmNhcmRzRmFpbGVkICsgKHJhdGluZyA9PT0gJ2FnYWluJyA/IDEgOiAwKSxcbiAgICAgICAgcmV2aWV3czogWy4uLnNlc3Npb24ucmV2aWV3cywgcmV2aWV3UmVjb3JkXVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgc2V0U2Vzc2lvbih1cGRhdGVkU2Vzc2lvbik7XG4gICAgICBzYXZlU2Vzc2lvbih1cGRhdGVkU2Vzc2lvbik7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSBsb2NhbCBzdGF0ZVxuICAgIGNvbnN0IHVwZGF0ZWRDYXJkcyA9IGNhcmRzLm1hcChjID0+IGMuaWQgPT09IHVwZGF0ZWRDYXJkLmlkID8gdXBkYXRlZENhcmQgOiBjKTtcbiAgICBzZXRDYXJkcyh1cGRhdGVkQ2FyZHMpO1xuICAgIFxuICAgIC8vIFJlbW92ZSBmcm9tIGR1ZSBjYXJkcyBpZiBubyBsb25nZXIgZHVlIChvciBtb3ZlIHRvIGVuZCBpZiBzdGlsbCBsZWFybmluZylcbiAgICBpZiAocmVzdWx0LnN0YXRlID09PSAnbGVhcm5pbmcnIHx8IHJlc3VsdC5zdGF0ZSA9PT0gJ3JlbGVhcm5pbmcnKSB7XG4gICAgICAvLyBLZWVwIGluIHF1ZXVlIGJ1dCBtb3ZlIHRvIGVuZFxuICAgICAgY29uc3QgbmV3RHVlID0gWy4uLmR1ZUNhcmRzXTtcbiAgICAgIGNvbnN0IGlkeCA9IG5ld0R1ZS5maW5kSW5kZXgoYyA9PiBjLmlkID09PSBjdXJyZW50Q2FyZC5pZCk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgbmV3RHVlLnNwbGljZShpZHgsIDEpO1xuICAgICAgICBuZXdEdWUucHVzaCh1cGRhdGVkQ2FyZCk7XG4gICAgICB9XG4gICAgICBzZXREdWVDYXJkcyhuZXdEdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1vdmUgZnJvbSBkdWUgY2FyZHNcbiAgICAgIGNvbnN0IG5ld0R1ZSA9IGR1ZUNhcmRzLmZpbHRlcihjID0+IGMuaWQgIT09IGN1cnJlbnRDYXJkLmlkKTtcbiAgICAgIHNldER1ZUNhcmRzKG5ld0R1ZSk7XG4gICAgICBcbiAgICAgIC8vIEFkanVzdCBpbmRleCBpZiBuZWVkZWRcbiAgICAgIGlmIChjdXJyZW50SW5kZXggPj0gZmlsdGVyZWREdWVDYXJkcy5sZW5ndGggLSAxICYmIGZpbHRlcmVkRHVlQ2FyZHMubGVuZ3RoID4gMSkge1xuICAgICAgICBzZXRDdXJyZW50SW5kZXgoTWF0aC5tYXgoMCwgY3VycmVudEluZGV4IC0gMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBSZXNldCBmb3IgbmV4dCBjYXJkXG4gICAgc2V0SXNSZXZlYWxlZChmYWxzZSk7XG4gICAgc2V0UmV2aWV3U3RhcnRUaW1lKG51bGwpO1xuICB9LCBbY3VycmVudENhcmQsIGNhcmRzLCBkdWVDYXJkcywgZmlsdGVyZWREdWVDYXJkcywgY3VycmVudEluZGV4LCBzZXNzaW9uLCByZXZpZXdTdGFydFRpbWVdKTtcblxuICAvLyBOYXZpZ2F0aW9uXG4gIGNvbnN0IG5leHRDYXJkID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChjdXJyZW50SW5kZXggPCBmaWx0ZXJlZER1ZUNhcmRzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHNldEN1cnJlbnRJbmRleChjdXJyZW50SW5kZXggKyAxKTtcbiAgICAgIHNldElzUmV2ZWFsZWQoZmFsc2UpO1xuICAgIH1cbiAgfSwgW2N1cnJlbnRJbmRleCwgZmlsdGVyZWREdWVDYXJkcy5sZW5ndGhdKTtcblxuICBjb25zdCBwcmV2aW91c0NhcmQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRJbmRleCA+IDApIHtcbiAgICAgIHNldEN1cnJlbnRJbmRleChjdXJyZW50SW5kZXggLSAxKTtcbiAgICAgIHNldElzUmV2ZWFsZWQoZmFsc2UpO1xuICAgIH1cbiAgfSwgW2N1cnJlbnRJbmRleF0pO1xuXG4gIGNvbnN0IGdvVG9DYXJkID0gdXNlQ2FsbGJhY2soKGluZGV4OiBudW1iZXIpID0+IHtcbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IGZpbHRlcmVkRHVlQ2FyZHMubGVuZ3RoKSB7XG4gICAgICBzZXRDdXJyZW50SW5kZXgoaW5kZXgpO1xuICAgICAgc2V0SXNSZXZlYWxlZChmYWxzZSk7XG4gICAgfVxuICB9LCBbZmlsdGVyZWREdWVDYXJkcy5sZW5ndGhdKTtcblxuICAvLyBTZXNzaW9uIG1hbmFnZW1lbnRcbiAgY29uc3Qgc3RhcnRTZXNzaW9uID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IG5ld1Nlc3Npb246IFJldmlld1Nlc3Npb24gPSB7XG4gICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcbiAgICAgIHN0YXJ0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgY2FyZHNSZXZpZXdlZDogMCxcbiAgICAgIGNhcmRzQ29ycmVjdDogMCxcbiAgICAgIGNhcmRzRmFpbGVkOiAwLFxuICAgICAgcmV2aWV3czogW11cbiAgICB9O1xuICAgIHNldFNlc3Npb24obmV3U2Vzc2lvbik7XG4gICAgc2V0Q3VycmVudEluZGV4KDApO1xuICAgIHNldElzUmV2ZWFsZWQoZmFsc2UpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgZW5kU2Vzc2lvbiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgY29uc3QgZW5kZWRTZXNzaW9uOiBSZXZpZXdTZXNzaW9uID0ge1xuICAgICAgICAuLi5zZXNzaW9uLFxuICAgICAgICBlbmRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH07XG4gICAgICBzYXZlU2Vzc2lvbihlbmRlZFNlc3Npb24pO1xuICAgIH1cbiAgICBzZXRTZXNzaW9uKG51bGwpO1xuICB9LCBbc2Vzc2lvbl0pO1xuXG4gIC8vIEFkZCBuZXcgY2FyZFxuICBjb25zdCBhZGRDYXJkID0gdXNlQ2FsbGJhY2soKFxuICAgIGNhcmREYXRhOiBPbWl0PEZsYXNoY2FyZCwgJ2lkJyB8ICdzY2hlbWFWZXJzaW9uJyB8ICdjcmVhdGVkQXQnIHwgJ3VwZGF0ZWRBdCc+XG4gICkgPT4ge1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICBjb25zdCBuZXdDYXJkOiBGbGFzaGNhcmQgPSB7XG4gICAgICAuLi5jYXJkRGF0YSxcbiAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxuICAgICAgc2NoZW1hVmVyc2lvbjogJzEuMCcsXG4gICAgICBjcmVhdGVkQXQ6IG5vdyxcbiAgICAgIHVwZGF0ZWRBdDogbm93XG4gICAgfTtcbiAgICBcbiAgICBzYXZlRmxhc2hjYXJkKG5ld0NhcmQpO1xuICAgIFxuICAgIGNvbnN0IHVwZGF0ZWRDYXJkcyA9IFsuLi5jYXJkcywgbmV3Q2FyZF07XG4gICAgc2V0Q2FyZHModXBkYXRlZENhcmRzKTtcbiAgICBcbiAgICAvLyBBZGQgdG8gZHVlIGNhcmRzIGlmIGl0J3MgZHVlXG4gICAgY29uc3QgZHVlID0gZ2V0RHVlQ2FyZHModXBkYXRlZENhcmRzKTtcbiAgICBzZXREdWVDYXJkcyhkdWUpO1xuICB9LCBbY2FyZHNdKTtcblxuICAvLyBBZGQgbXVsdGlwbGUgY2FyZHMgKG1lcmdlIHdpdGhvdXQgZHVwbGljYXRlcylcbiAgY29uc3QgYWRkQ2FyZHMgPSB1c2VDYWxsYmFjaygobmV3Q2FyZHM6IEZsYXNoY2FyZFtdKSA9PiB7XG4gICAgY29uc3QgZXhpc3RpbmdJZHMgPSBuZXcgU2V0KGNhcmRzLm1hcChjID0+IGMuaWQpKTtcbiAgICBcbiAgICAvLyBGaWx0ZXIgb3V0IGNhcmRzIHRoYXQgYWxyZWFkeSBleGlzdCAoYnkgSUQpXG4gICAgLy8gQWxzbyBjaGVjayBmb3IgZHVwbGljYXRlIGNvbnRlbnRcbiAgICBjb25zdCBleGlzdGluZ0NvbnRlbnQgPSBuZXcgU2V0KGNhcmRzLm1hcChjID0+IGMuY29udGVudC5mcm9udC50b0xvd2VyQ2FzZSgpLnRyaW0oKSkpO1xuICAgIFxuICAgIGNvbnN0IHVuaXF1ZU5ld0NhcmRzID0gbmV3Q2FyZHMuZmlsdGVyKG5ld0NhcmQgPT4ge1xuICAgICAgY29uc3QgaXNEdXBsaWNhdGVJZCA9IGV4aXN0aW5nSWRzLmhhcyhuZXdDYXJkLmlkKTtcbiAgICAgIGNvbnN0IGlzRHVwbGljYXRlQ29udGVudCA9IGV4aXN0aW5nQ29udGVudC5oYXMobmV3Q2FyZC5jb250ZW50LmZyb250LnRvTG93ZXJDYXNlKCkudHJpbSgpKTtcbiAgICAgIHJldHVybiAhaXNEdXBsaWNhdGVJZCAmJiAhaXNEdXBsaWNhdGVDb250ZW50O1xuICAgIH0pO1xuXG4gICAgaWYgKHVuaXF1ZU5ld0NhcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5sb2coJ05vIG5ldyB1bmlxdWUgY2FyZHMgdG8gYWRkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTWVyZ2Ugd2l0aCBleGlzdGluZyBjYXJkc1xuICAgIGNvbnN0IG1lcmdlZENhcmRzID0gWy4uLmNhcmRzLCAuLi51bmlxdWVOZXdDYXJkc107XG4gICAgXG4gICAgLy8gU2F2ZSB0byBzdG9yYWdlXG4gICAgc2F2ZUZsYXNoY2FyZHMobWVyZ2VkQ2FyZHMpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBzdGF0ZVxuICAgIHNldENhcmRzKG1lcmdlZENhcmRzKTtcbiAgICBzZXREdWVDYXJkcyhnZXREdWVDYXJkcyhtZXJnZWRDYXJkcykpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGBBZGRlZCAke3VuaXF1ZU5ld0NhcmRzLmxlbmd0aH0gbmV3IGNhcmRzYCk7XG4gIH0sIFtjYXJkc10pO1xuXG4gIC8vIFVwZGF0ZSBleGlzdGluZyBjYXJkXG4gIGNvbnN0IHVwZGF0ZUNhcmQgPSB1c2VDYWxsYmFjaygodXBkYXRlZENhcmQ6IEZsYXNoY2FyZCkgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZWQgPSB7IC4uLnVwZGF0ZWRDYXJkLCB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9O1xuICAgIHNhdmVGbGFzaGNhcmQodXBkYXRlZCk7XG4gICAgXG4gICAgY29uc3QgdXBkYXRlZENhcmRzID0gY2FyZHMubWFwKGMgPT4gYy5pZCA9PT0gdXBkYXRlZC5pZCA/IHVwZGF0ZWQgOiBjKTtcbiAgICBzZXRDYXJkcyh1cGRhdGVkQ2FyZHMpO1xuICAgIHNldER1ZUNhcmRzKGdldER1ZUNhcmRzKHVwZGF0ZWRDYXJkcykpO1xuICB9LCBbY2FyZHNdKTtcblxuICAvLyBEZWxldGUgY2FyZFxuICBjb25zdCBkZWxldGVDYXJkID0gdXNlQ2FsbGJhY2soKGlkOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCB1cGRhdGVkQ2FyZHMgPSBjYXJkcy5maWx0ZXIoYyA9PiBjLmlkICE9PSBpZCk7XG4gICAgc2F2ZUZsYXNoY2FyZHModXBkYXRlZENhcmRzKTtcbiAgICBzZXRDYXJkcyh1cGRhdGVkQ2FyZHMpO1xuICAgIHNldER1ZUNhcmRzKGdldER1ZUNhcmRzKHVwZGF0ZWRDYXJkcykpO1xuICB9LCBbY2FyZHNdKTtcblxuICByZXR1cm4ge1xuICAgIGNhcmRzLFxuICAgIGR1ZUNhcmRzLFxuICAgIGZpbHRlcmVkRHVlQ2FyZHMsXG4gICAgY3VycmVudENhcmQsXG4gICAgY3VycmVudEluZGV4LFxuICAgIGlzUmV2ZWFsZWQsXG4gICAgaXNMb2FkaW5nLFxuICAgIHN0YXRzLFxuICAgIHNlc3Npb24sXG4gICAgaW50ZXJ2YWxQcmV2aWV3LFxuICAgIGZpbHRlcnMsXG4gICAgYXZhaWxhYmxlVGFncyxcbiAgICBhdmFpbGFibGVTeXN0ZW1zLFxuICAgIHRvcGljUGVyZm9ybWFuY2UsXG4gICAgcmV2ZWFsQW5zd2VyLFxuICAgIHJhdGVDYXJkLFxuICAgIG5leHRDYXJkLFxuICAgIHByZXZpb3VzQ2FyZCxcbiAgICBnb1RvQ2FyZCxcbiAgICBzdGFydFNlc3Npb24sXG4gICAgZW5kU2Vzc2lvbixcbiAgICBhZGRDYXJkLFxuICAgIGFkZENhcmRzLFxuICAgIHVwZGF0ZUNhcmQsXG4gICAgZGVsZXRlQ2FyZCxcbiAgICByZWZyZXNoQ2FyZHMsXG4gICAgc2V0RmlsdGVycyxcbiAgICBjbGVhckZpbHRlcnMsXG4gICAgdG9nZ2xlVGFnLFxuICAgIHRvZ2dsZVN5c3RlbVxuICB9O1xufVxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJnZXRGbGFzaGNhcmRzIiwic2F2ZUZsYXNoY2FyZCIsInNhdmVGbGFzaGNhcmRzIiwic2VlZEZsYXNoY2FyZHMiLCJzYXZlU2Vzc2lvbiIsImdldEZpbHRlcnMiLCJzYXZlRmlsdGVycyIsInNjaGVkdWxlQ2FyZCIsImdldER1ZUNhcmRzIiwiY2FsY3VsYXRlU3RhdHMiLCJwcmV2aWV3U2NoZWR1bGUiLCJkZWZhdWx0RmlsdGVycyIsInRhZ3MiLCJzeXN0ZW1zIiwicm90YXRpb25zIiwic3RhdGVzIiwiZGlmZmljdWx0aWVzIiwidXNlRmxhc2hjYXJkcyIsImNhcmRzIiwic2V0Q2FyZHMiLCJkdWVDYXJkcyIsInNldER1ZUNhcmRzIiwiY3VycmVudEluZGV4Iiwic2V0Q3VycmVudEluZGV4IiwiaXNSZXZlYWxlZCIsInNldElzUmV2ZWFsZWQiLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJzZXNzaW9uIiwic2V0U2Vzc2lvbiIsInJldmlld1N0YXJ0VGltZSIsInNldFJldmlld1N0YXJ0VGltZSIsImludGVydmFsUHJldmlldyIsInNldEludGVydmFsUHJldmlldyIsImZpbHRlcnMiLCJzZXRGaWx0ZXJzU3RhdGUiLCJsb2FkZWRDYXJkcyIsImR1ZSIsInNhdmVkRmlsdGVycyIsImF2YWlsYWJsZVRhZ3MiLCJBcnJheSIsImZyb20iLCJTZXQiLCJmbGF0TWFwIiwiYyIsIm1ldGFkYXRhIiwic29ydCIsImF2YWlsYWJsZVN5c3RlbXMiLCJtYXAiLCJzeXN0ZW0iLCJ0b3BpY1BlcmZvcm1hbmNlIiwidG9waWNNYXAiLCJNYXAiLCJmb3JFYWNoIiwiY2FyZCIsImtleSIsInRvcGljIiwiaGFzIiwic2V0IiwiZ2V0IiwicHVzaCIsImVudHJpZXMiLCJkYXRhIiwidG90YWxDYXJkcyIsImxlbmd0aCIsInJldmlld2VkQ2FyZHMiLCJmaWx0ZXIiLCJzcGFjZWRSZXBldGl0aW9uIiwicmVwcyIsImNvcnJlY3RDb3VudCIsInJlZHVjZSIsInN1bSIsImluY29ycmVjdENvdW50IiwibGFwc2VzIiwiYXZlcmFnZUVhc2UiLCJlYXNlIiwidG90YWxBdHRlbXB0cyIsInJldGVudGlvblJhdGUiLCJzdHJlbmd0aCIsImEiLCJiIiwiZmlsdGVyZWREdWVDYXJkcyIsImhhc01hdGNoaW5nVGFnIiwic29tZSIsInQiLCJpbmNsdWRlcyIsInJvdGF0aW9uIiwic3RhdGUiLCJkaWZmaWN1bHR5IiwiY3VycmVudENhcmQiLCJzdGF0cyIsInJlZnJlc2hDYXJkcyIsInNldEZpbHRlcnMiLCJuZXdGaWx0ZXJzIiwiY2xlYXJGaWx0ZXJzIiwidG9nZ2xlVGFnIiwidGFnIiwidG9nZ2xlU3lzdGVtIiwicyIsInJldmVhbEFuc3dlciIsIkRhdGUiLCJub3ciLCJyYXRlQ2FyZCIsInJhdGluZyIsInJlc3VsdCIsInVwZGF0ZWRDYXJkIiwidXBkYXRlZEF0IiwidG9JU09TdHJpbmciLCJpbnRlcnZhbCIsIm5leHRSZXZpZXciLCJsYXN0UmV2aWV3Iiwic3RhYmlsaXR5IiwicmV2aWV3UmVjb3JkIiwiY2FyZElkIiwiaWQiLCJyZXZpZXdlZEF0IiwidGltZVNwZW50IiwicHJldmlvdXNTdGF0ZSIsIm5ld1N0YXRlIiwidXBkYXRlZFNlc3Npb24iLCJjYXJkc1Jldmlld2VkIiwiY2FyZHNDb3JyZWN0IiwiY2FyZHNGYWlsZWQiLCJyZXZpZXdzIiwidXBkYXRlZENhcmRzIiwibmV3RHVlIiwiaWR4IiwiZmluZEluZGV4Iiwic3BsaWNlIiwiTWF0aCIsIm1heCIsIm5leHRDYXJkIiwicHJldmlvdXNDYXJkIiwiZ29Ub0NhcmQiLCJpbmRleCIsInN0YXJ0U2Vzc2lvbiIsIm5ld1Nlc3Npb24iLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwic3RhcnRlZEF0IiwiZW5kU2Vzc2lvbiIsImVuZGVkU2Vzc2lvbiIsImVuZGVkQXQiLCJhZGRDYXJkIiwiY2FyZERhdGEiLCJuZXdDYXJkIiwic2NoZW1hVmVyc2lvbiIsImNyZWF0ZWRBdCIsImFkZENhcmRzIiwibmV3Q2FyZHMiLCJleGlzdGluZ0lkcyIsImV4aXN0aW5nQ29udGVudCIsImNvbnRlbnQiLCJmcm9udCIsInRvTG93ZXJDYXNlIiwidHJpbSIsInVuaXF1ZU5ld0NhcmRzIiwiaXNEdXBsaWNhdGVJZCIsImlzRHVwbGljYXRlQ29udGVudCIsImNvbnNvbGUiLCJsb2ciLCJtZXJnZWRDYXJkcyIsInVwZGF0ZUNhcmQiLCJ1cGRhdGVkIiwiZGVsZXRlQ2FyZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useFlashcards.ts\n"));

/***/ })

});